<!DOCTYPE html>
<html lang="es">
<head>
	<!-- Halloween mode: inject pumpkin emoji favicon -->
	<link rel="icon" type="image/png" href="https://img.icons8.com/emoji/48/000000/jack-o-lantern.png" />

	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
	<title>Red Zenon</title>
	<link rel="icon" type="image/png" href="assets/logo1.png" />
	<link rel="stylesheet" href="css/style.css" />
	<link rel="stylesheet" href="css/login-fix.css" />
	<link rel="preconnect" href="https://www.gstatic.com" crossorigin />
	<link rel="preconnect" href="https://firebasestorage.googleapis.com" crossorigin />
	<style>
		:root {
			--bg: #0a0b10;
			--bg-grad-a: #0a0b10;
			--bg-grad-b: #0f1630;
			--panel: #11131a;
			--panel-grad-a: #11131a;
			--panel-grad-b: #0f1118;
			--muted: #a9b2c0;
			--text: #eef2f8;
			--primary: #9c86ff;
			--primary-strong: #7a63f1;
			--accent: #ffbe0b;
			--danger: #ff6b6b;
			--success: #55d69c;
			--border: #1d2130;
			--shadow: rgba(0,0,0,0.5);
		}
		html, body { height: 100%; }
		body {
			margin: 0;
			background: radial-gradient(1200px 800px at 10% 0%, var(--bg-grad-b), transparent) ,
				linear-gradient(180deg, var(--bg-grad-a) 0%, var(--bg-grad-b) 100%);
			color: var(--text);
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
			display: flex;
			align-items: center;
			justify-content: center;
		}
		.container {
			width: 100%;
			max-width: 1600px;
			padding: 24px;
		}
		#loginCard { max-width: 760px; margin: 0 auto; }
		#loginCard .content { padding: 28px 22px 28px 22px; }
		#loginCard .login-grid { gap: 14px; }
		#loginCard .actions { margin-top: 10px; }
		.card {
			background: linear-gradient(180deg, var(--panel-grad-a), var(--panel-grad-b));
			border: 1px solid var(--border);
			border-radius: 14px;
			overflow: hidden;
			box-shadow: 0 16px 40px var(--shadow);
			position: relative;
		}
		.header {
			padding: 18px 20px;
			border-bottom: 1px solid var(--border);
			display: flex;
			align-items: center;
			justify-content: space-between;
		}
		.title { font-size: 18px; font-weight: 600; letter-spacing: 0.3px; }
		.badge { font-size: 12px; padding: 4px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); background: #0f121a; }
		.badge-logo { 
			width: 1.15em; 
			height: 1.15em; 
			object-fit: contain; 
			vertical-align: middle; 
			margin: 0 6px; 
		}
        #nameBadge { cursor: pointer; user-select: none; }
        #nameBadge.copied { border-color: rgba(156,134,255,0.6); box-shadow: 0 0 0 2px rgba(156,134,255,0.2) inset; }
        
		.content { padding: 18px; }
		.login-grid { display: grid; gap: 12px; }
		.field { display: grid; gap: 6px; }
		.label { color: var(--muted); font-size: 13px; }
		.input {
			background: #0e0e0f;
			color: var(--text);
			border: 1px solid var(--border);
			border-radius: 6px;
			padding: 13px 14px;
			outline: none;
		}
		.input:focus { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(156, 134, 255, 0.18); }
		.actions { display: flex; gap: 12px; align-items: center; justify-content: flex-end; margin-top: 6px; }
		.btn {
			border: 1px solid var(--border);
			background: linear-gradient(180deg, #1a1b22, #12131a);
			color: var(--text);
			padding: 10px 14px;
			border-radius: 10px;
			cursor: pointer;
			transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
		}
		.btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.25); border-color: #2a2f45; }
		.btn.primary { border-color: rgba(156,134,255,0.35); background: linear-gradient(180deg, #262341, #191a2a); color: #ede9ff; }
		.btn.primary:hover { border-color: rgba(156,134,255,0.6); box-shadow: 0 8px 22px rgba(124,102,255,0.18); }
		.error { color: var(--danger); font-size: 13px; min-height: 18px; }
	#loginBtn { padding: 12px 18px; font-size: 15px; }
		.chat-wrapper { height: 70vh; display: grid; grid-template-rows: 1fr auto auto; gap: 12px; }
		.messages {
			position: relative;
			background: radial-gradient(900px 420px at 110% -10%, rgba(156,134,255,0.06), transparent), #0f1116;
			border: 1px solid var(--border);
			border-radius: 12px;
			padding: 12px;
			overflow: auto;
			display: flex;
			flex-direction: column;
		}
		.messages::before {
			content: '';
			position: absolute;
			inset: 0;
			pointer-events: none;
			background: url('assets/logo.png') no-repeat center center;
			background-size: clamp(160px, 40%, 420px);
			opacity: 0.04;
		}
		.msg { margin: 10px 0; display: flex; flex-direction: column; gap: 6px; max-width: 75%; }
		.msg.from-user { align-self: flex-start; }
		.msg.from-admin { align-self: flex-end; }
		.meta { color: var(--muted); font-size: 12px; display: flex; gap: 8px; align-items: center; }
		.msg.from-admin .meta { flex-direction: row-reverse; }
		.meta .role { padding: 2px 6px; border-radius: 999px; border: 1px solid var(--border); }
		.meta .role.admin { color: var(--success); border-color: rgba(85,214,156,0.35); }
		.meta .role.user { color: var(--primary); border-color: rgba(77,163,255,0.35); }
		.bubble { padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: #11131a; box-shadow: 0 8px 18px rgba(0,0,0,0.18) inset; }
		.msg.from-user .bubble { 
			background: linear-gradient(180deg, #111625, #0f1220); 
			border-color: #20243a; 
			border-radius: 10px 10px 10px 2px;
		}
		.msg.from-admin .bubble { 
			background: linear-gradient(180deg, #0f1b17, #0d1513); 
			border-color: #1f2f2a;
			border-radius: 10px 10px 2px 10px;
		}
		.text { font-size: 15px; line-height: 1.5; }
		.composer { display: grid; grid-template-columns: minmax(0,1fr) 48px 48px 48px auto; gap: 10px; }
		.composer .input { width: 100%; }
		.composer { grid-template-columns: 1fr auto auto auto auto; }
		.composer .btn.icon { width: 44px; display: inline-flex; align-items: center; justify-content: center; padding: 0; font-size: 18px; border-color: #23283d; }
		#messageInput { margin-right: 6px; width: calc(100% - 20px); justify-self: start; }
		.shortcuts { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
		.panels-section { margin-top: 14px; }
		.panels-title { margin: 6px 2px 6px; font-weight: 600; color: #e6e9f3; }
		.panels { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
		.cajero-section { margin-top: 16px; }
		.cajero-title { margin: 6px 2px 6px; font-weight: 600; color: #e6e9f3; }
		.cajero { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
		.shortcut-card, .panel-card, .danger-card {
			width: 100%; min-width: 0; min-height: 64px;
			display: inline-flex; align-items: center; justify-content: center;
			border: 1px solid var(--border); border-radius: 10px;
			background: linear-gradient(180deg, #262341, #191a2a);
			color: #ede9ff; font-weight: 600; letter-spacing: .2px;
			cursor: pointer; user-select: none;
			transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
			border-color: rgba(156,134,255,0.35);
		}
		.shortcut-card:hover, .panel-card:hover, .danger-card:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.25); border-color: rgba(156,134,255,0.6); }
		.danger-card {
			background: linear-gradient(180deg, #3a1520, #1f0c12);
			border-color: #b32b45;
			color: #ffd7de;
		}
		.shortcut-card:active { transform: translateY(0); }
		.image-msg { margin-top: 4px; }
		.image-msg img { max-width: 100%; height: auto; border-radius: 10px; border: 1px solid var(--border); cursor: pointer; }
		.image-msg.sticker-msg { max-width: 200px; }
		.image-msg.sticker-msg img { max-width: 180px; width: 180px; height: auto; border: none; border-radius: 8px; }
		.audio-msg { 
			margin-top: 4px; 
			min-width: clamp(240px, 42vw, 380px);
			max-width: 100%;
		}
		.audio-msg audio { 
			width: 100%; 
			outline: none; 
			background: linear-gradient(180deg, #141726, #101320);
			border: 1px solid var(--border);
			border-radius: 8px;
			padding: 4px 8px;
			filter: invert(0.85) hue-rotate(200deg) saturate(0.7);
		}
		/* Reacciones */
		.reaction-heart { font-size: 18px; margin-top: 2px; user-select: none; filter: drop-shadow(0 1px 1px rgba(0,0,0,0.35)); }
		.msg.from-admin .reaction-heart { align-self: flex-end; }
		.msg.from-user .reaction-heart { align-self: flex-start; }
		/* Bot√≥n de eliminar mensaje */
		.delete-message-btn {
			position: absolute;
			top: 6px;
			right: 6px;
			width: 24px;
			height: 24px;
			border-radius: 6px;
			background: linear-gradient(180deg, #3a1520, #2a1016);
			border: 1px solid #b32b45;
			color: #ffd7de;
			font-size: 14px;
			display: none;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			opacity: 0;
			transition: opacity 0.2s ease, transform 0.1s ease;
			z-index: 10;
		}
		.delete-message-btn:hover {
			background: linear-gradient(180deg, #4a1828, #3a1420);
			transform: scale(1.1);
		}
		.msg { position: relative; }
		.msg:hover .delete-message-btn {
			opacity: 1;
		}
		/* Tooltip de copiado */
		.copy-tooltip {
			position: absolute;
			bottom: 100%;
			left: 50%;
			transform: translateX(-50%) translateY(-8px);
			background: linear-gradient(135deg, #55d69c, #4ac98a);
			color: #fff;
			padding: 8px 16px;
			border-radius: 12px;
			font-size: 13px;
			font-weight: 600;
			white-space: nowrap;
			pointer-events: none;
			z-index: 1000;
			box-shadow: 0 4px 16px rgba(85, 214, 156, 0.4);
			animation: slideUpFade 0.3s ease-out, fadeOut 0.3s ease-in 2s forwards;
			display: flex;
			align-items: center;
			gap: 6px;
		}
		.copy-tooltip::before {
			content: '‚úì';
			font-size: 16px;
			font-weight: bold;
		}
		.copy-tooltip::after {
			content: '';
			position: absolute;
			top: 100%;
			left: 50%;
			transform: translateX(-50%);
			width: 0;
			height: 0;
			border-left: 6px solid transparent;
			border-right: 6px solid transparent;
			border-top: 6px solid #4ac98a;
		}
		@keyframes slideUpFade {
			from {
				opacity: 0;
				transform: translateX(-50%) translateY(0);
			}
			to {
				opacity: 1;
				transform: translateX(-50%) translateY(-8px);
			}
		}
		@keyframes fadeOut {
			to {
				opacity: 0;
				transform: translateX(-50%) translateY(-12px);
			}
		}
		/* Efecto de presionado */
		.msg.pressing {
			transform: scale(0.98);
			transition: transform 0.1s ease;
		}
		/* Bot√≥n toggle para panel de accesos r√°pidos */
		#shortcutsToggleBtn {
			position: fixed;
			right: 20px;
			top: 50%;
			transform: translateY(-50%);
			width: 32px;
			height: 64px;
			background: linear-gradient(135deg, var(--primary), var(--primary-strong));
			border: 1px solid var(--border);
			border-radius: 8px;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			font-size: 18px;
			color: #fff;
			transition: all 0.3s ease;
			z-index: 9999;
			box-shadow: 0 4px 16px rgba(0,0,0,0.3);
		}
		#shortcutsToggleBtn:hover {
			background: linear-gradient(135deg, var(--primary-strong), var(--primary));
			transform: translateY(-50%) scale(1.1);
			box-shadow: 0 6px 20px rgba(156,134,255,0.5);
		}
		#shortcutsToggleBtn:active {
			transform: translateY(-50%) scale(0.95);
		}
		#shortcutsCard {
			position: relative;
			transition: all 0.3s ease;
		}
		#shortcutsCard.collapsed {
			width: 0 !important;
			min-width: 0 !important;
			max-width: 0 !important;
			padding: 0 !important;
			margin: 0 !important;
			border: none !important;
			overflow: hidden;
			opacity: 0;
		}
		#shortcutsCard.collapsed .header,
		#shortcutsCard.collapsed .content {
			display: none;
		}
		#chatRow {
			transition: gap 0.3s ease;
			position: relative;
		}
		#chatRow.shortcuts-collapsed {
			gap: 0 !important;
		}
		.file-msg {
			margin-top: 4px;
			display: flex;
			align-items: center;
			gap: 10px;
			min-width: clamp(220px, 42vw, 420px);
			max-width: 100%;
		}
		.file-msg .file-icon {
			font-size: 22px;
		}
		.file-msg .file-details {
			display: flex;
			flex-direction: column;
			gap: 4px;
		}
		.file-msg a {
			color: var(--accent);
			text-decoration: none;
			font-weight: 600;
			word-break: break-word;
		}
		.file-msg .file-meta {
			font-size: 12px;
			color: var(--muted);
		}
		.image-preview {
			background: linear-gradient(180deg, #121424, #0f111a);
			border: 1px solid var(--border);
			border-radius: 12px;
			padding: 10px;
			display: flex;
			gap: 12px;
			align-items: center;
		}
		.image-preview img {
			height: 64px;
			width: 64px;
			object-fit: cover;
			border-radius: 8px;
			border: 1px solid var(--border);
		}
		.image-preview .info { flex: 1; min-width: 0; }
		.image-preview .name { font-size: 14px; color: #e6e6e6; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		.image-preview .actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 6px; }
		.file-preview-icon {
			width: 64px;
			height: 64px;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: 8px;
			border: 1px solid var(--border);
			background: linear-gradient(180deg, #16182c, #121422);
			font-size: 28px;
		}
		#pdfPreview .size { font-size: 12px; color: var(--muted); margin-top: 4px; }
		.recording { background: linear-gradient(180deg, #2a1014, #1a0e12); border: 1px solid #3a1520; border-radius: 12px; padding: 10px; display: none; align-items: center; gap: 10px; }
		.recording .dot { width: 10px; height: 10px; border-radius: 50%; background: #ff4d4d; box-shadow: 0 0 12px #ff4d4d; animation: blink 1s infinite; }
		.recording .txt { color: #ffd7d7; font-size: 14px; }
		.recording .time { color: #ffb1b1; font-size: 13px; margin-left: auto; }
		@keyframes blink { 0%, 50% { opacity: 1 } 50.01%, 100% { opacity: .35 } }
		#userListPanel { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: linear-gradient(180deg, #10131c, #0f1118); }
		#userListPanel { max-height: 70vh; overflow: auto; display: flex; flex-direction: column; }
		#userListPanel > div:first-child { color: #e6e9f3; }
		#userList .btn { gap: 10px; display: flex; align-items: center; background: linear-gradient(180deg, #141726, #101320); border-color: #1f2234; color: #e6e9f3; }
		#userList .btn:hover { border-color: #2b3050; box-shadow: 0 6px 16px rgba(0,0,0,0.25); }
		.list-avatar { width: 18px; height: 18px; border-radius: 4px; object-fit: contain; filter: drop-shadow(0 0 4px rgba(255,190,11,0.25)); }
		dialog { 
			border: 1px solid var(--border); 
			border-radius: 12px; 
			background: linear-gradient(180deg, #10131c, #0f1116); 
			box-shadow: 0 24px 70px var(--shadow);
			color: var(--text);
		}
		dialog::backdrop { background: rgba(0,0,0,0.55); backdrop-filter: blur(2px); }
		.sound-dialog { display:block; }
		.sound-dialog .dialog-header { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:12px; }
		.sound-dialog .dialog-title { font-weight:700; font-size:16px; }
		.dialog-status { font-size:13px; color:#cfd6e6; margin-bottom:12px; }
		.sound-dialog .dialog-actions { display:flex; gap:10px; justify-content:flex-end; margin-top:10px; }
		#soundFileInput { 
			width:100%; 
			background: linear-gradient(180deg, #141726, #101320); 
			border: 1px solid var(--border); 
			border-radius: 10px; 
			color: var(--muted); 
			padding: 10px; 
		}
		#soundFileInput::file-selector-button {
			border: 1px solid rgba(156,134,255,0.35);
			background: linear-gradient(180deg, #262341, #191a2a);
			color: #ede9ff;
			padding: 8px 12px;
			margin-right: 10px;
			border-radius: 8px;
			cursor: pointer;
			transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
		}
		#soundFileInput::file-selector-button:hover { transform: translateY(-1px); box-shadow: 0 6px 16px rgba(0,0,0,0.25); border-color: rgba(156,134,255,0.6); }
		#soundVolumeRange { 
			width: 100%; 
			height: 6px; 
			appearance: none; 
			background: linear-gradient(180deg, #141726, #101320);
			border: 1px solid var(--border);
			border-radius: 999px; 
			outline: none; 
		}
		#soundVolumeRange::-webkit-slider-thumb { appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #7a63f1; border: 2px solid #b2a6ff33; box-shadow: 0 2px 8px rgba(122,99,241,0.45); cursor: pointer; }
		#soundVolumeRange::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #7a63f1; border: 2px solid #b2a6ff33; box-shadow: 0 2px 8px rgba(122,99,241,0.45); cursor: pointer; }
		body.closed-hours { padding-top: 60px; }
		#closedBanner {
			position: fixed;
			top: 0; left: 0; right: 0;
			z-index: 9999;
			background: linear-gradient(180deg, #3a1520, #1f0c12);
			border-bottom: 1px solid #b32b45;
			box-shadow: 0 10px 24px rgba(179,43,69,0.25);
			color: #ffd7de;
			display: none;
		}
		#closedBanner .inner {
			max-width: 1600px;
			margin: 0 auto;
			padding: 12px 24px;
			display: flex;
			align-items: center;
			gap: 12px;
			font-weight: 700;
			letter-spacing: .2px;
		}
		#closedBanner .badge {
			background: #5a1e2b;
			border-color: #b32b45;
			color: #ffd7de;
		}
		#closedFullOverlay {
			position: fixed; inset: 0; z-index: 10000; display: none;
			background: linear-gradient(180deg, rgba(10,11,16,0.85), rgba(10,11,16,0.92));
			backdrop-filter: blur(2px);
			align-items: center; justify-content: center; text-align: center;
		}
		#closedFullOverlay .cardy {
			max-width: 720px; margin: 0 16px; padding: 22px 20px;
			border-radius: 14px; border: 1px solid #b32b45;
			background: linear-gradient(180deg, #3a1520, #1f0c12);
			box-shadow: 0 24px 64px rgba(179,43,69,0.35);
			position: relative; overflow: hidden;
		}
		#closedFullOverlay .stamp {
			position: absolute; inset: -40px; display: grid; place-items: center; pointer-events: none;
			font-size: 64px; font-weight: 900; letter-spacing: 4px; color: #ffb1c0; opacity: 0.08;
			transform: rotate(-18deg);
		}
		#closedFullOverlay .title { font-size: 22px; font-weight: 800; color: #ffd7de; }
		#closedFullOverlay .subtitle { margin-top: 6px; color: #ffb1c0; font-size: 15px; }
		#closedFullOverlay .note { margin-top: 10px; color: #ffd7de; opacity: .95; font-size: 13px; }
		#closedFullOverlay .actions { margin-top: 14px; display: flex; gap: 10px; justify-content: center; }
		#closedDismissBtn {
			border: 1px solid rgba(255,215,222,0.35);
			background: linear-gradient(180deg, #262341, #191a2a);
			color: #fff; padding: 10px 14px; border-radius: 10px; cursor: pointer;
		}
		.closed-overlay {
			position: absolute; inset: 0;
			display: none; /* visible en horario cerrado */
			align-items: center; justify-content: center;
			pointer-events: none; /* no bloquea el chat */
			background: radial-gradient(800px 400px at 50% 20%, rgba(179,43,69,0.14), transparent);
		}
		.closed-overlay .panel {
			pointer-events: none;
			padding: 16px 18px;
			border-radius: 12px;
			border: 1px solid #b32b45;
			background: linear-gradient(180deg, #3a1520, #1f0c12);
			box-shadow: 0 16px 44px rgba(179,43,69,0.28);
			max-width: 560px;
			text-align: center;
		}
		.closed-overlay .panel .title { font-size: 18px; font-weight: 800; color: #ffd7de; margin-bottom: 6px; }
		.closed-overlay .panel .desc { font-size: 14px; color: #ffb1c0; }

		/* Age gate overlay */
		#ageOverlay {
			position: fixed; inset: 0; z-index: 10001; display: none;
			background: linear-gradient(180deg, rgba(10,11,16,0.85), rgba(10,11,16,0.92));
			backdrop-filter: blur(2px);
			align-items: center; justify-content: center; text-align: center;
		}
		#ageOverlay .cardy {
			max-width: 720px; margin: 0 16px; padding: 22px 20px;
			border-radius: 14px; border: 1px solid #2a2f45;
			background: linear-gradient(180deg, #141726, #101320);
			box-shadow: 0 24px 64px rgba(0,0,0,0.35);
		}
		#ageOverlay .title { font-size: 22px; font-weight: 800; color: #ede9ff; }
		#ageOverlay .subtitle { margin-top: 6px; color: #cfd6e6; font-size: 15px; }
		#ageOverlay .note { margin-top: 10px; color: #a9b2c0; font-size: 13px; }
		#ageOverlay .actions { margin-top: 14px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }

		/* Mobile: ocupar toda la pantalla para el chat */
		@media (max-width: 768px) {
			body { align-items: stretch; }
			.container { padding: 0; max-width: 100%; }
			#chatRow { gap: 0; }
			.card { border-radius: 0; }
			#chatCard { 
				display: flex; 
				flex-direction: column; 
				height: calc(var(--vh, 1vh) * 100);
				max-height: calc(var(--vh, 1vh) * 100);
			}
			#chatCard .content { 
				flex: 1; 
				overflow: hidden; 
				display: flex; 
				gap: 12px; 
				padding: 12px; 
			}
			#userListPanel { display: none !important; }
			#shortcutsCard { display: none !important; }
			.chat-wrapper { height: 100%; }
			.messages { min-height: 0; }
			.composer { gap: 8px; }
			#messageInput { margin-right: 0; }
		}
	</style>
	<link rel="manifest" href="/manifest.webmanifest">
	<meta name="theme-color" content="#0a0b10">
</head>
<body class="halloween">
	<!-- Halloween banner -->
	<div style="width:100vw;max-width:100vw;background:#2c1a2c;color:#ffb347;padding:10px 0;text-align:center;font-size:20px;z-index:10000;box-shadow:0 2px 24px #ff7518aa;position:fixed;top:0;left:0;">
		üéÉ ¬°Feliz Halloween! üëª Disfruta la noche m√°s espeluznante del a√±o con nosotros üï∏Ô∏è
	</div>
	<div style="height:44px;"></div>
	<div id="closedBanner" role="status" aria-live="polite">
		<div class="inner">
			<span style="font-size:18px">‚è∞</span>
			<div style="flex:1">
				<strong>Fuera de horario de atenci√≥n</strong>
				<span style="opacity:.9">¬∑ 04:00‚Äì8:00 (Buenos Aires)</span>
				<div style="font-weight:500;color:#ffd7de;opacity:.9; font-size:13px;">El administrador no est√° activo ahora. Pod√©s dejar tu mensaje; responderemos a partir de las 8:00.</div>
			</div>
			<span class="badge" style="font-weight:700">CERRADO</span>
		</div>
	</div>
	<div id="closedFullOverlay" aria-modal="true" role="dialog">
		<div class="cardy">
			<div class="stamp">CERRADO</div>
			<div class="title">Fuera de horario</div>
			<div class="subtitle">El administrador no est√° activo entre <strong>04:00</strong> y <strong>8:00</strong> (Buenos Aires).</div>
			<div class="note">Pod√©s dejar tu mensaje con tranquilidad; lo veremos a partir de las 8:00. Gracias por tu paciencia.</div>
			<div class="actions">
				<button id="closedDismissBtn" type="button">Entendido</button>
			</div>
		</div>
	</div>
	<div class="container">
		<div class="card" id="loginCard">
			<div class="header">
				<div class="title">Pone tus datos para chatear</div>
			</div>
			<div class="content" style="max-width: 680px;">
				<div class="login-grid">
					<div class="field">
						<label class="label" for="username">Usuario</label>
						<input class="input" id="username" type="text" placeholder="Tu usuario" />
					</div>
					<div class="field">
						<label class="label" for="password">Contrase√±a</label>
						<input class="input" id="password" type="password" placeholder="Tu contrase√±a" />
					</div>
					<div class="error" id="loginError"></div>
					<div class="actions">
						<button class="btn primary" id="loginBtn" type="button">Ingresar</button>
					</div>
					<div class="label">En usuario y contrase√±a siempre van tus datos de juego, no te confundas con tu nombre de usuario y tu contrase√±a no te la olvides/cambies</div>
				</div>
			</div>
		</div>
			<div id="chatRow" class="chat-row" style="display:none; gap: 18px; align-items: stretch;">
			<div class="card" id="chatCard" style="display:none;flex:1;">
				<div class="header">
					<div class="title"><img src="assets/logo.png" alt="Logo" class="badge-logo" style="margin-right:8px"/>Cajeros linea 2 (kensho, enzo, rukka, jynx)</div>
					<div>
						<span class="badge" id="nameBadge">-</span>
						<span class="badge" id="adminNoteBadge" style="display:none;"></span>
						<button class="btn" id="logoutBtn" type="button" title="Cerrar sesi√≥n">Salir</button>
					</div>
				</div>
				<div class="content" style="display: flex; gap: 18px;">
					<div id="userListPanel" style="min-width:220px;max-width:260px;display:none;">
						<div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:10px;">
							<div style="font-size:15px;font-weight:600;">Usuarios</div>
							<div style="flex:1;display:flex;gap:6px;align-items:center;justify-content:flex-end;">
								<span title="Buscar" style="opacity:.8">üîé</span>
								<input id="userSearch" type="text" placeholder="Buscar" class="input" style="height:30px;padding:6px 10px;max-width:140px;" />
							</div>
						</div>
						<div id="userList" style="display:flex;flex-direction:column;gap:6px;"></div>
					</div>
					<div class="chat-wrapper" style="flex:1;">
						<div class="messages" id="messages"></div>
						<div class="recording" id="recordingBar">
							<div class="dot"></div>
							<div class="txt">Manten√© presionado para grabar</div>
							<div class="time" id="recordingTime">00:00</div>
						</div>
						<div class="image-preview" id="imagePreview" style="display:none">
							<img id="imagePreviewThumb" alt="preview" loading="lazy" decoding="async" />
							<div class="info">
								<div class="name" id="imagePreviewName">imagen</div>
								<div class="actions">
									<button class="btn" id="cancelImageBtn" type="button">Cancelar</button>
									<button class="btn primary" id="confirmImageBtn" type="button">Enviar imagen</button>
								</div>
							</div>
						</div>
						<div class="image-preview" id="audioPreview" style="display:none">
							<audio id="audioPreviewPlayer" controls style="width:140px"></audio>
							<div class="info">
								<div class="name" id="audioPreviewName">grabaci√≥n</div>
								<div class="actions">
									<button class="btn" id="cancelAudioBtn" type="button">Cancelar</button>
									<button class="btn primary" id="confirmAudioBtn" type="button">Enviar audio</button>
								</div>
							</div>
						</div>
						<div class="image-preview" id="pdfPreview" style="display:none">
							<div class="file-preview-icon" id="pdfPreviewIcon" aria-hidden="true">üìÑ</div>
							<div class="info">
								<div class="name" id="pdfPreviewName">documento.pdf</div>
								<div class="size" id="pdfPreviewSize"></div>
								<div class="actions">
									<button class="btn" id="cancelPdfBtn" type="button">Cancelar</button>
									<button class="btn primary" id="confirmPdfBtn" type="button">Enviar PDF</button>
								</div>
							</div>
						</div>
						<div class="composer">
							<input class="input" id="messageInput" type="text" placeholder="Escribe un mensaje y presiona Enter..." />
							<button class="btn icon" id="audioBtn" type="button" title="Mantener para grabar">üé§</button>
							<button class="btn icon" id="imageBtn" type="button" title="Enviar imagen">üì∑</button>
							<button class="btn icon" id="pdfBtn" type="button" title="Enviar PDF">üìÑ</button>
							<button class="btn primary" id="sendBtn" type="button">Enviar</button>
							<input type="file" id="imageInput" accept="image/*" style="display:none" />
							<input type="file" id="pdfInput" accept="application/pdf" style="display:none" />
						</div>
					</div>
					<div id="closedOverlay" class="closed-overlay">
						<div class="panel">
							<div class="title">‚è∞ Fuera de horario</div>
							<div class="desc">El administrador no est√° activo entre <strong>04:00</strong> y <strong>8:00</strong> (Buenos Aires). Pod√©s dejar tu mensaje; responderemos a partir de las 8:00.</div>
						</div>
					</div>
				</div>
			</div>
			<button id="shortcutsToggleBtn" title="Ocultar/Mostrar panel" style="display:none;">‚óÄ</button>
			<div class="card" id="shortcutsCard" style="display:none;min-width:260px;max-width:300px;">
				<div class="header">
					<div class="title">Accesos r√°pidos</div>
				</div>
				<div class="content">
					<div class="shortcuts">
						<div class="shortcut-card" id="shortcutGanamos" title="Enviar: https://www.ganamos.pw/">ganamos</div>
						<div class="shortcut-card" id="shortcutZeus" title="Enviar: https://www.casinozeus26.com/">ZEUS</div>
						<div class="shortcut-card" id="shortcutBet30" title="Enviar: https://www.bet30.gold/">BET30</div>
						<div class="shortcut-card" id="shortcutCamel" title="Enviar: https://www.camelbet24.com/">CAMEL</div>
						<div class="shortcut-card" id="shortcutGnaCsa" title="Enviar: http://ganaencasa24.com/">gna.csa</div>
						<div class="shortcut-card" id="shortcutCelu" title="Enviar: https://www.celuapuestas24.ws/">CELU</div>
						<div class="shortcut-card" id="shortcutFortu" title="Enviar: http://fortubet24.ws/">FORTU</div>
						<div class="shortcut-card" id="shortcutArgen" title="Enviar: https://argenbet.net/">ARGEN</div>
						<div class="shortcut-card" id="shortcutPoseidon" title="Enviar: https://granposeidon.eu/">poseidon</div>
					</div>

					<div class="panels-section">
						<div class="panels-title">Paneles</div>
						<div class="panels">
							<div class="panel-card" id="panelGnmos" title="https://bo.ganamos.pw/login">GNMOS</div>
							<div class="panel-card" id="panelArgen" title="https://admin.argenbet.net/users/all">ARGEN</div>
							<div class="panel-card" id="panelG32" title="https://bo.casinoenvivo.club/login">G32</div>
						</div>
					</div>
					<div class="cajero-section">
						<div class="cajero-title">Cajero</div>
						<div class="cajero">

							<div class="panel-card" id="btnCajeroSound" title="Elegir sonido de notificaciones personalizado">NOTIFI.</div>
						<div class="panel-card" id="btnCajeroSticker" title="Enviar un sticker divertido al chat">STICKER</div>
						<div class="panel-card" id="btnCajeroSupport" title="En caso de tener un problema, contactarse al siguiente n√∫mero de whatsapp: +54 1164147048">SOPORTE</div>
						</div>
					</div>
				</div>
			</div>
			</div>
	</div>
	<div id="ageOverlay" aria-modal="true" role="dialog">
		<div class="cardy">
			<div class="title">Verificaci√≥n de edad</div>
			<div class="subtitle">Para continuar, confirm√° que sos mayor de 18 a√±os.</div>
			<div id="ageMsg" class="note"></div>
			<div class="actions">
				<button class="btn" id="ageNoBtn" type="button">No, soy menor</button>
				<button class="btn primary" id="ageYesBtn" type="button">S√≠, soy mayor de 18</button>
			</div>
		</div>
	</div>
	<dialog id="imgDialog">
		<img id="imgDialogImg" alt="imagen" loading="lazy" decoding="async" />
	</dialog>
	<dialog id="soundDialog">
		<form method="dialog" style="min-width:280px;max-width:460px;padding:16px;" class="sound-dialog">
			<div class="dialog-header">
				<div class="dialog-title">Sonido de notificaciones</div>
				<button id="soundCloseBtn" class="btn" value="close" type="submit">Cerrar</button>
			</div>
			<div id="soundStatus" class="dialog-status">Actual: predeterminado</div>
			<div class="range-wrap" style="margin:8px 0 12px;">
				<label for="soundVolumeRange" class="label" style="display:block;margin-bottom:6px;">Volumen: <span id="soundVolumeValue">100%</span></label>
				<input id="soundVolumeRange" type="range" min="0" max="100" value="100" />
			</div>
			<input id="soundFileInput" type="file" accept="audio/*" style="width:100%;margin-bottom:10px;" />
			<div class="dialog-actions">
				<button type="button" id="soundPermissionBtn" class="btn">Forzar permisos</button>
				<button type="button" id="soundTestBtn" class="btn">Probar</button>
				<button type="button" id="soundSaveBtn" class="btn primary">Guardar</button>
				<button type="button" id="soundResetBtn" class="btn">Quitar personalizado</button>
			</div>
		</form>
	</dialog>

	<script type="module">
	import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
	import { getDatabase, ref, push, serverTimestamp, onChildAdded, onChildChanged, query, limitToLast, limitToFirst, onValue, off, set, remove, get, orderByChild, endAt, update } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js';
	import { getFirestore, collection, doc, addDoc, setDoc, deleteDoc, serverTimestamp as fsServerTimestamp, onSnapshot, where, query as fsQuery, getDocs, writeBatch, orderBy } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js';
	import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-functions.js';

		const firebaseConfig = {
			apiKey: "AIzaSyB3Fjr_lu4mRECh_QCbF1thuVfTYkf42eQ",
			authDomain: "chisspero.firebaseapp.com",
			projectId: "chisspero",
			storageBucket: "chisspero.firebasestorage.app",
			messagingSenderId: "178897843769",
			appId: "1:178897843769:web:4ec8db86e6dd045b16ffe8",
			measurementId: "G-7H53CKR4T6",
			databaseURL: "https://chisspero-default-rtdb.firebaseio.com"
		};

		const app = initializeApp(firebaseConfig);
		const db = getDatabase(app);
		const fs = getFirestore(app);
		const functionsClient = getFunctions(app);
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.register('/sw.js').catch(() => {});
		}
		function updateViewportUnit() {
			const vh = window.innerHeight * 0.01;
			document.documentElement.style.setProperty('--vh', `${vh}px`);
		}
		updateViewportUnit();
		window.addEventListener('resize', updateViewportUnit, { passive: true });
		window.addEventListener('orientationchange', updateViewportUnit);
		const loginCard = document.getElementById('loginCard');
		const chatRow = document.getElementById('chatRow');
		const chatCard = document.getElementById('chatCard');
		const usernameEl = document.getElementById('username');
		const passwordEl = document.getElementById('password');
		const loginBtn = document.getElementById('loginBtn');
		const loginError = document.getElementById('loginError');
		const nameBadge = document.getElementById('nameBadge');
		const adminNoteBadge = document.getElementById('adminNoteBadge');
		const messagesEl = document.getElementById('messages');
		const shortcutsCard = document.getElementById('shortcutsCard');
		const shortcutGanamos = document.getElementById('shortcutGanamos');
		const shortcutZeus = document.getElementById('shortcutZeus');
		const shortcutBet30 = document.getElementById('shortcutBet30');
		const shortcutCamel = document.getElementById('shortcutCamel');
		const shortcutGnaCsa = document.getElementById('shortcutGnaCsa');
		const shortcutCelu = document.getElementById('shortcutCelu');
		const shortcutFortu = document.getElementById('shortcutFortu');
		const shortcutArgen = document.getElementById('shortcutArgen');
		const shortcutPoseidon = document.getElementById('shortcutPoseidon');
		const panelG32 = document.getElementById('panelG32');
		const panelGnmos = document.getElementById('panelGnmos');
		const panelArgen = document.getElementById('panelArgen');
		const btnCajeroClear = document.getElementById('btnCajeroClear');
		const btnCajeroSound = document.getElementById('btnCajeroSound');
		const btnCajeroSupport = document.getElementById('btnCajeroSupport');
		const soundDialog = document.getElementById('soundDialog');
		const soundFileInput = document.getElementById('soundFileInput');
		const soundStatus = document.getElementById('soundStatus');
		const soundPermissionBtn = document.getElementById('soundPermissionBtn');
		const soundTestBtn = document.getElementById('soundTestBtn');
		const soundSaveBtn = document.getElementById('soundSaveBtn');
		const soundResetBtn = document.getElementById('soundResetBtn');
		const soundVolumeRange = document.getElementById('soundVolumeRange');
		const soundVolumeValue = document.getElementById('soundVolumeValue');
		const messageInput = document.getElementById('messageInput');
		const sendBtn = document.getElementById('sendBtn');
		const imageBtn = document.getElementById('imageBtn');
		const audioBtn = document.getElementById('audioBtn');
		const imageInput = document.getElementById('imageInput');
		const pdfBtn = document.getElementById('pdfBtn');
		const pdfInput = document.getElementById('pdfInput');
		const logoutBtn = document.getElementById('logoutBtn');
		const recordingBar = document.getElementById('recordingBar');
		const recordingTimeEl = document.getElementById('recordingTime');
		const imagePreview = document.getElementById('imagePreview');
		const imagePreviewThumb = document.getElementById('imagePreviewThumb');
		const imagePreviewName = document.getElementById('imagePreviewName');
		const confirmImageBtn = document.getElementById('confirmImageBtn');
		const cancelImageBtn = document.getElementById('cancelImageBtn');
		const pdfPreview = document.getElementById('pdfPreview');
		const pdfPreviewName = document.getElementById('pdfPreviewName');
		const pdfPreviewSize = document.getElementById('pdfPreviewSize');
		const confirmPdfBtn = document.getElementById('confirmPdfBtn');
		const cancelPdfBtn = document.getElementById('cancelPdfBtn');
		const audioPreview = document.getElementById('audioPreview');
		const audioPreviewPlayer = document.getElementById('audioPreviewPlayer');
		const audioPreviewName = document.getElementById('audioPreviewName');
		const confirmAudioBtn = document.getElementById('confirmAudioBtn');
		const cancelAudioBtn = document.getElementById('cancelAudioBtn');
		const imgDialog = document.getElementById('imgDialog');
		const imgDialogImg = document.getElementById('imgDialogImg');
		const closedBanner = document.getElementById('closedBanner');
		const closedOverlay = document.getElementById('closedOverlay');
		const closedFullOverlay = document.getElementById('closedFullOverlay');
		const closedDismissBtn = document.getElementById('closedDismissBtn');
		const ageOverlay = document.getElementById('ageOverlay');
		const ageYesBtn = document.getElementById('ageYesBtn');
		const ageNoBtn = document.getElementById('ageNoBtn');
		const ageMsg = document.getElementById('ageMsg');
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.addEventListener('message', (event) => {
				try {
					const data = event.data || {};
					if (data.type === 'shared-files' && Array.isArray(data.files)) {
						// Reconstruir archivos desde datos serializados
						const reconstructedFiles = data.files.map(fileData => {
							if (fileData.arrayBuffer) {
								// Archivo serializado desde el SW
								return new File([fileData.arrayBuffer], fileData.name, {
									type: fileData.type,
									lastModified: fileData.lastModified
								});
							}
							// Fallback para formato antiguo
							return fileData;
						}).filter(Boolean);
						
						const pdf = reconstructedFiles.find(f => f && (f.type === 'application/pdf' || /\.pdf$/i.test(f.name || '')));
						shareLaunchFlag = true;
						if (pdf) {
							if (isLoggedInFlag && currentUser && currentUser.name) {
								// Enviar directo sin vista previa
								sendPdfAttachment(pdf).catch(() => {});
							} else {
								pendingSharedPdfFile = pdf;
							}
						}
					}
				} catch (err) {
					console.error('Error procesando archivos compartidos:', err);
				}
			});
		}

		// Eventos del age gate
		if (ageYesBtn) {
			ageYesBtn.addEventListener('click', () => {
				try { localStorage.setItem('age18Confirmed', '1'); } catch {}
				if (ageOverlay) ageOverlay.style.display = 'none';
				document.body.style.overflow = '';
			});
		}
		if (ageNoBtn) {
			ageNoBtn.addEventListener('click', () => {
			// Redirigir a p√°gina principal de Google si indica que es menor
			try { window.location.replace('https://www.google.com/'); } catch { window.location.href = 'https://www.google.com/'; }
		});
	}

	// Enviar sticker al chat
	const btnCajeroSticker = document.getElementById('btnCajeroSticker');
	if (btnCajeroSticker) {
		btnCajeroSticker.onclick = async function() {
			await sendStickerMessage();
		};
	}

	async function sendStickerMessage() {
		try {
			// Determinar la clave del chat actual
			let userChatKey = null;
			if (currentUser.role === 'admin') {
				if (!selectedUserKey) return;
				userChatKey = selectedUserKey;
			} else {
				userChatKey = currentUser.name;
			}
			if (!userChatKey) return;
			const stickerUrl = 'assets/sticker.jpg';
			

			// Construir y guardar directamente en Firestore (sin pasar por RTDB)
			const now = nowMs();
			const docRef = await addDoc(collection(fs, 'mensajes'), {
				i: stickerUrl,
				s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
				r: currentUser.role,
				x: now,
				y: 'i', // tipo imagen
				isSticker: true,
				userKey: userChatKey,
				userKeyNormalized: (userChatKey || '').toLowerCase(),
				createdAt: fsServerTimestamp()
			});

			// Renderizar localmente usando el id de Firestore
			appendMessageOnce(docRef.id, {
				i: stickerUrl,
				s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
				r: currentUser.role,
				x: now,
				y: 'i',
				isSticker: true
			}, userChatKey);

			// Actualizar metadata de la conversaci√≥n
			try {
				await upsertConversationMetadata(userChatKey, {
					type: 'image',
					sender: payload.sender,
					role: payload.role,
					ts: now
				});
			} catch (err) {
				console.warn('No se pudo actualizar metadata de conversaci√≥n (sticker):', err);
			}
		} catch (error) {
			console.error('Error al enviar sticker:', error);
			alert('No se pudo enviar el sticker. Intentalo de nuevo');
		}
	}		let pendingImageFile = null;
		let uploadingImage = false;
		let pendingPdfFile = null;
		let sendingPdf = false;
		let pdfPreviewOwnerKey = null;
		// Share-target: archivo PDF recibido para env√≠o autom√°tico
		let pendingSharedPdfFile = null;
		let shareLaunchFlag = false;
		let mediaRecorder = null;
		let audioChunks = [];
		let recordingTimer = null;
		let recordingStartedAt = 0;
		let pendingAudioDataUrl = null;
		let sendingAudio = false;
		let audioPreviewOwnerKey = null; // due√±o de la vista previa de audio
		let pendingAudioSizeKB = 0; // tama√±o aprox del audio
		let imagePreviewOwnerKey = null; // due√±o de la vista previa de imagen

		const USER1 = 'fundador666';
		const USER2 = 'linea2bet';
		const FIRESTORE_HISTORY_LIMIT = 500; // Cantidad m√°xima de mensajes persistidos a recuperar por chat
		const INACTIVITY_TIMEOUT_MS = 1000 * 60 * 5; // 5 minutos de inactividad (solo usuarios)
		const NEW_MESSAGE_MAX_AGE_MS = 10000; // Considerar "nuevo" todo mensaje con menos de 10s
		const SUPPORT_WHATSAPP_MESSAGE = 'En caso de tener un problema, contactarse al n√∫mero de whatsapp: +54 1164147048';
		const ADMIN_CLEAR_TOKEN = (() => {
			try { return btoa(`${USER1}:${USER2}`); } catch { return `${USER1}:${USER2}`; }
		})();

	let currentUser = { name: null, role: 'user' };
	let selectedUserKey = null;
	let chatListener = null;
	let conversations = {};
	let conversationMeta = {};
	let unsubscribeAliases = null;
	let unsubscribeConversationsMeta = null;
	let unsubscribeHistoryFS = null;
	let renderedMessageIds = new Set();
	let messagesScrollHandler = null;
	let inactivityTimerId = null;
	let inactivityHandlersBound = false;
	let notificationSound = null; // buffer por defecto (Web Audio)
	let customNotificationDataUrl = null; // data URL del sonido personalizado
	let customNotificationAudio = null; // elemento de audio reutilizable
	let pendingCustomSoundDataUrl = null; // data URL cargado en el di√°logo, a√∫n no guardado
	let unreadCounts = {}; // { userKey: count }
	let lastMessageTimestamps = {}; // Para detectar mensajes nuevos
	let notificationsEnabled = false;
	let audioContextSingleton = null;
	let knownUserKeys = new Set();
	let userListHydrated = false;
	let isLoggedInFlag = false;
	let serverTimeOffsetMs = 0;
	let adminReadState = {};
	let unsubscribeAdminReads = null;
	let adminNotes = {};
	let unsubscribeAdminNotes = null;
	let userAliases = {}; // Ahora se cargar√° desde Firestore

	let messageIndex = new Map();

	onValue(ref(db, '.info/serverTimeOffset'), (snap) => {
		try { serverTimeOffsetMs = Number(snap.val() || 0); } catch { serverTimeOffsetMs = 0; }
	}, { onlyOnce: false });

	function nowMs(){ return Date.now() + (serverTimeOffsetMs || 0); }

	// Formato de fecha/hora en 24 hs para AR
	function formatDateTime24(input){
		try {
			const d = (input instanceof Date) ? input : new Date(input);
			return new Intl.DateTimeFormat('es-AR', {
				timeZone: 'America/Argentina/Buenos_Aires',
				hour12: false,
				day: '2-digit',
				month: '2-digit',
				hour: '2-digit',
				minute: '2-digit'
			}).format(d);
		} catch { return '-'; }
	}

	function getLastMessageTs(userKey){
		const meta = conversationMeta[userKey];
		return (meta && typeof meta.lmts === 'number') ? meta.lmts : 0;
	}
	function isClosedHoursBuenosAires(date = new Date()) {
		try {
			const parts = new Intl.DateTimeFormat('es-AR', { timeZone: 'America/Argentina/Buenos_Aires', hour12: false, hour: 'numeric' }).formatToParts(date);
			const hourStr = parts.find(p => p.type === 'hour')?.value || '0';
			const hour = parseInt(hourStr, 10);
			return hour >= 4 && hour < 8;
		} catch {
			return false;
		}
	}

	function isAdminRole() {
		const r = (currentUser?.role || '').toLowerCase();
		return r === 'admin' || r === 'cajero';
	}

		function ensureAgeGate() {
			try {
				const ok = localStorage.getItem('age18Confirmed') === '1';
				if (!ok) {
					if (ageOverlay) ageOverlay.style.display = 'flex';
					// opcional: bloquear scroll
					document.body.style.overflow = 'hidden';
				}
			} catch {}
		}

	function updateClosedStateUI() {
		const closed = isClosedHoursBuenosAires();
		const admin = isAdminRole();
		if (closedBanner) closedBanner.style.display = closed ? '' : 'none';
		if (closedOverlay) closedOverlay.style.display = (closed && !admin && isLoggedInFlag) ? 'flex' : 'none';
		// Full overlay solo cuando el usuario ya est√° logueado (para no bloquear el login) y no es admin
		const dismissed = sessionStorage.getItem('closedOverlayDismissed') === '1';
		if (closedFullOverlay) {
			closedFullOverlay.style.display = (closed && !admin && isLoggedInFlag && !dismissed) ? 'flex' : 'none';
		}
		try {
			document.body.classList.toggle('closed-hours', closed);
		} catch {}
	}

		function bindInactivityEvents() {
			if (inactivityHandlersBound) return;
			const reset = () => resetInactivityTimer();
			window.addEventListener('mousemove', reset);
			window.addEventListener('keydown', reset);
			window.addEventListener('click', reset);
			window.addEventListener('touchstart', reset, { passive: true });
			document.addEventListener('visibilitychange', () => {
				if (document.visibilityState === 'visible') resetInactivityTimer();
			});
			inactivityHandlersBound = true;
		}

		function startInactivityWatch() {
			if (currentUser.role === 'admin') return;
			bindInactivityEvents();
			resetInactivityTimer();
		}

		function stopInactivityWatch() {
			if (inactivityTimerId) {
				clearTimeout(inactivityTimerId);
				inactivityTimerId = null;
			}
		}

		function resetInactivityTimer() {
			if (currentUser.role === 'admin') return;
			if (inactivityTimerId) clearTimeout(inactivityTimerId);
			inactivityTimerId = setTimeout(() => {
				try { messageInput.blur(); } catch {}
				setView(false);
				const el = document.getElementById('loginError');
				if (el) el.textContent = 'Sesi√≥n cerrada por inactividad (5 minutos).';
			}, INACTIVITY_TIMEOUT_MS);
		}

		// Utilidad: copiar texto al portapapeles con fallback
		async function copyToClipboard(text){
			try {
				if (navigator.clipboard && window.isSecureContext) {
					await navigator.clipboard.writeText(String(text || ''));
					return true;
				}
			} catch {}
			try {
				const ta = document.createElement('textarea');
				ta.value = String(text || '');
				ta.setAttribute('readonly','');
				ta.style.position = 'fixed';
				ta.style.top = '-9999px';
				document.body.appendChild(ta);
				ta.focus();
				ta.select();
				const ok = document.execCommand('copy');
				document.body.removeChild(ta);
				return !!ok;
			} catch { return false; }
		}

	function setView(isLoggedIn) {
		isLoggedInFlag = !!isLoggedIn;
		loginCard.style.display = isLoggedIn ? 'none' : '';
		if (chatRow) chatRow.style.display = isLoggedIn ? 'flex' : 'none';
		chatCard.style.display = isLoggedIn ? '' : 'none';
		const isAdmin = currentUser.role === 'admin';
		document.getElementById('userListPanel').style.display = (isLoggedIn && isAdmin) ? '' : 'none';
		if (shortcutsCard) shortcutsCard.style.display = (isLoggedIn && isAdmin) ? '' : 'none';
		
		// Mostrar/ocultar bot√≥n toggle del panel
		const shortcutsToggleBtn = document.getElementById('shortcutsToggleBtn');
		if (shortcutsToggleBtn) {
			shortcutsToggleBtn.style.display = (isLoggedIn && isAdmin) ? 'flex' : 'none';
		}

		const logoutBtn = document.getElementById('logoutBtn');
		if (isLoggedIn) {
			messageInput.value = '';
			messageInput.focus();
			if (logoutBtn) logoutBtn.style.display = isAdmin ? '' : 'none';
			if (isAdmin) {
				if (adminNoteBadge) adminNoteBadge.style.display = '';
				selectedUserKey = selectedUserKey || null;
				ensureAdminSubscriptions();
				// Solicitar permisos de notificaciones para el admin
				requestNotificationPermission();
				stopInactivityWatch && stopInactivityWatch();
			} else {
				if (adminNoteBadge) adminNoteBadge.style.display = 'none';
				teardownAdminSubscriptions();
				selectedUserKey = currentUser.name;
				loadChat(selectedUserKey);
				startInactivityWatch && startInactivityWatch();
			}
		} else {
			if (logoutBtn) logoutBtn.style.display = 'none';
			if (adminNoteBadge) adminNoteBadge.style.display = 'none';
			teardownAdminSubscriptions();
			usernameEl.focus();
			selectedUserKey = null;
			clearChat();
			clearUserList();
			// Al salir, limpiar vistas previas en UI y estado
			try { clearImagePreview && clearImagePreview(); } catch {}
			try { clearAudioPreview && clearAudioPreview(); } catch {}
			stopInactivityWatch && stopInactivityWatch();
		}

		updateActiveChatHeader();
		updateClosedStateUI();
	}


		// ========== SISTEMA DE NOTIFICACIONES ==========
		function getAudioContext() {
			try {
				const Ctor = window.AudioContext || window.webkitAudioContext;
				if (!Ctor) return null;
				if (!audioContextSingleton || audioContextSingleton.state === 'closed') {
					audioContextSingleton = new Ctor();
				}
				return audioContextSingleton;
			} catch (err) {
				console.warn('No se pudo inicializar AudioContext:', err);
				return null;
			}
		}

		function createNotificationSound() {
			const audioContext = getAudioContext();
			if (!audioContext) return null;
			if (notificationSound) return notificationSound;
			const duration = 0.3;
			const sampleRate = audioContext.sampleRate;
			const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
			const data = buffer.getChannelData(0);
			for (let i = 0; i < buffer.length; i++) {
				const t = i / sampleRate;
				const freq1 = 800; // Primera nota
				const freq2 = 1000; // Segunda nota
				const envelope = Math.exp(-3 * t);
				if (t < duration / 2) {
					data[i] = Math.sin(2 * Math.PI * freq1 * t) * envelope * 0.3;
				} else {
					data[i] = Math.sin(2 * Math.PI * freq2 * t) * envelope * 0.3;
				}
			}
			notificationSound = buffer;
			return notificationSound;
		}
		function playNotificationSound() {

			// Eliminado: toast de copiado (requerimiento: copiar sin avisos visuales)
			// Si hay sonido personalizado, usarlo
			if (customNotificationDataUrl) {
				try {
					if (!customNotificationAudio) {
						customNotificationAudio = new Audio(customNotificationDataUrl);
						customNotificationAudio.preload = 'auto';
					}
					// Reiniciar y reproducir
					try { customNotificationAudio.currentTime = 0; } catch {}
					// Aplicar volumen guardado
					try { customNotificationAudio.volume = getSavedVolume(); } catch {}
					customNotificationAudio.play().catch(() => {
						// Si falla por pol√≠tica del navegador, caer al beep
						playDefaultBeep();
					});
					return;
				} catch (err) {
					console.warn('No se pudo reproducir sonido personalizado, usando beep:', err);
				}
			}
			playDefaultBeep();
		}

		function playDefaultBeep() {
			try {
				const audioContext = getAudioContext();
				if (!audioContext) return;
				if (audioContext.state === 'suspended') {
					audioContext.resume().catch(() => {});
				}
				const buffer = createNotificationSound();
				if (!buffer) return;
				const source = audioContext.createBufferSource();
				source.buffer = buffer;
				const gain = audioContext.createGain();
				gain.gain.value = getSavedGain();
				source.connect(gain);
				gain.connect(audioContext.destination);
				source.start(0);
			} catch (err) {
				console.warn('No se pudo reproducir el beep:', err);
			}
		}

		function getSavedVolume() {
			try {
				const v = localStorage.getItem('notificationVolume');
				const num = v == null ? 1 : Math.max(0, Math.min(1, Number(v)));
				return isNaN(num) ? 1 : num;
			} catch { return 1; }
		}

		function getSavedGain() {
			return getSavedVolume();
		}

		function loadCustomNotificationSoundFromStorage() {
			try {
				const v = localStorage.getItem('customNotificationSound');
				customNotificationDataUrl = v || null;
				customNotificationAudio = v ? new Audio(v) : null;
				if (customNotificationAudio) customNotificationAudio.preload = 'auto';
			} catch {}
		}

		function setCustomNotificationSound(dataUrl) {
			customNotificationDataUrl = dataUrl;
			try { localStorage.setItem('customNotificationSound', dataUrl); } catch {}
			customNotificationAudio = new Audio(dataUrl);
			customNotificationAudio.preload = 'auto';
		}

		function clearCustomNotificationSound() {
			customNotificationDataUrl = null;
			customNotificationAudio = null;
			try { localStorage.removeItem('customNotificationSound'); } catch {}
		}

		// Solicitar permisos de notificaciones
		async function requestNotificationPermission(opts = {}) {
			const force = !!(opts && opts.force);
			if (!('Notification' in window)) {
				console.warn('Este navegador no soporta notificaciones');
				notificationsEnabled = false;
				return false;
			}
			if (Notification.permission === 'granted') {
				notificationsEnabled = true;
				updateSoundStatusLabel && updateSoundStatusLabel();
				return true;
			}
			if (Notification.permission === 'denied' && !force) {
				notificationsEnabled = false;
				updateSoundStatusLabel && updateSoundStatusLabel();
				return false;
			}
			try {
				const permission = await Notification.requestPermission();
				notificationsEnabled = permission === 'granted';
				updateSoundStatusLabel && updateSoundStatusLabel();
				return notificationsEnabled;
			} catch (err) {
				console.warn('No se pudo solicitar permiso de notificaciones:', err);
				notificationsEnabled = Notification.permission === 'granted';
				updateSoundStatusLabel && updateSoundStatusLabel();
				return notificationsEnabled;
			}
			return false;
		}

		// Mostrar notificaci√≥n Push
		function showNotification(title, body, icon = 'assets/logo.png') {
			// Forzar la notificaci√≥n: si no hay permiso, solicitarlo autom√°ticamente
			if (Notification.permission === 'default') {
				Notification.requestPermission().then(permission => {
					if (permission === 'granted') {
						notificationsEnabled = true;
						showNotificationNow(title, body, icon);
					}
				});
				return;
			}
			
			if (Notification.permission !== 'granted') {
				console.warn('Notificaciones no permitidas');
				return;
			}
			
			showNotificationNow(title, body, icon);
		}
		
		function showNotificationNow(title, body, icon) {
			try {
				const notification = new Notification(title, {
					body: body,
					icon: icon,
					badge: icon,
					tag: 'mensaje-nuevo',
					requireInteraction: false,
					silent: false,
					vibrate: [200, 100, 200]
				});
				setTimeout(() => notification.close(), 6000);
				notification.onclick = () => {
					window.focus();
					notification.close();
				};
			} catch (err) {
				console.warn('Error al mostrar notificaci√≥n:', err);
			}
		}
		function getLatestMessageSummary(userKey) {
			if (!userKey) return '';
			const meta = conversationMeta[userKey];
			if (meta && meta.lmp) {
				return meta.lmp;
			}
			return '';
		}

		function notifyNewConversation(userKey) {
			if (currentUser.role !== 'admin') return;
			if (!userListHydrated) return;
			if (!userKey || userKey === selectedUserKey) return;
			// No notificar si ya est√° le√≠do o si es viejo
			const lastTs = getLastMessageTs(userKey);
			const readTs = adminReadState[userKey] || 0;
			// Solo notificar si el √∫ltimo mensaje es realmente m√°s nuevo que el √∫ltimo le√≠do y no es viejo
			if (!lastTs || lastTs <= readTs) return;
			// Si el chat se abre y el √∫ltimo mensaje no cambi√≥, no notificar
			if (lastMessageTimestamps[userKey] && lastMessageTimestamps[userKey] === lastTs) return;
			const age = nowMs() - (lastTs || 0);
			if (age > NEW_MESSAGE_MAX_AGE_MS) return;
			lastMessageTimestamps[userKey] = lastTs;
			const displayName = getDisplayName(userKey) || userKey;
			const body = getLatestMessageSummary(userKey) || 'Nuevo chat disponible';
			console.log('üîî Nueva conversaci√≥n detectada:', displayName, body);
			playNotificationSound();
			showNotification(`üí¨ ${displayName}`, body);
		}
		function incrementUnread(userKey) {
			if (!userKey || userKey === selectedUserKey) return;
			unreadCounts[userKey] = (unreadCounts[userKey] || 0) + 1;
			renderUserList();
		}
		function clearUnread(userKey) {
			if (unreadCounts[userKey]) {
				delete unreadCounts[userKey];
				renderUserList();
			}
		}

		// Persistir "le√≠do" para administrador
		async function markChatRead(userKey) {
			try {
				if (!userKey || currentUser.role !== 'admin') return;
				const ts = nowMs();
				adminReadState[userKey] = ts;
				try { localStorage.setItem('adminReadsCache', JSON.stringify(adminReadState)); } catch {}
				try { delete unreadCounts[userKey]; } catch {}
				renderUserList();
				await setDoc(doc(fs, 'adminState', 'reads'), { [userKey]: ts }, { merge: true });
			} catch (err) {
				console.warn('No se pudo marcar como le√≠do', err);
			}
		}

		// Detectar mensajes nuevos y notificar (solo para admin)
		function handleNewMessage(userKey, message) {
			if (currentUser.role !== 'admin') return;
			if (!message) return;
			// Adaptar claves cortas
			const roleVal = message.r || message.role;
			if (roleVal === 'admin') return;
			const tsVal = message.x || message.ts || message.timestamp || nowMs();
			const readTs = adminReadState[userKey] || 0;
			// Siempre notificar si el mensaje es realmente nuevo (mayor al √∫ltimo le√≠do)
			if (tsVal > readTs) {
				// Evitar duplicados: solo si no fue notificado antes
				if (!lastMessageTimestamps[userKey] || tsVal > lastMessageTimestamps[userKey]) {
					lastMessageTimestamps[userKey] = tsVal;
					playNotificationSound();
					if (userKey !== selectedUserKey) {
						incrementUnread(userKey);
					}
					// Mostrar notificaci√≥n Push
					const userName = getDisplayName(userKey) || userKey;
					let notifBody = '';
					const textVal = message.t || message.text;
					const imageVal = message.i || message.imageDataUrl || message.imageUrl;
					const pdfVal = message.p || message.pdfDataUrl || message.pdfUrl;
					const audioVal = message.a || message.audioDataUrl;
					const nameVal = message.n || message.name;
					if (textVal) {
						notifBody = textVal.length > 50 ? textVal.substring(0, 50) + '...' : textVal;
					} else if (imageVal) {
						notifBody = 'üì∑ Imagen';
					} else if (pdfVal) {
						notifBody = nameVal ? `üìÑ ${nameVal}` : 'üìÑ PDF';
					} else if (audioVal) {
						notifBody = 'üé§ Audio';
					} else {
						notifBody = 'Mensaje nuevo';
					}
					console.log('üîî Mostrando notificaci√≥n para:', userName, notifBody);
					showNotification(`üí¨ ${userName}`, notifBody);
				}
			}
		}

			function getDisplayName(userKey) {
				if (!userKey) return userKey;
				return userAliases[userKey] || userAliases[(userKey.toLowerCase ? userKey.toLowerCase() : userKey)] || userKey;
		} 			function updateActiveChatHeader() {
				let baseName = '-';
				if (selectedUserKey) {
					baseName = getDisplayName(selectedUserKey) || selectedUserKey || '-';
				} else if (currentUser.role !== 'admin') {
					baseName = currentUser.name || '-';
				}
				nameBadge.textContent = baseName;
				try { nameBadge.dataset.base = baseName; } catch {}
				
				// Actualizar nota del admin
				if (currentUser.role === 'admin' && selectedUserKey) {
					const note = adminNotes[selectedUserKey] || '';
					if (adminNoteBadge) {
						adminNoteBadge.textContent = note || '(vac√≠o)';
						adminNoteBadge.style.display = '';
					}
				} else {
					if (adminNoteBadge) adminNoteBadge.style.display = 'none';
				}
			}				// Hacer clic en el nombre para copiarlo (sin modificar el texto)
				if (nameBadge && !nameBadge.dataset.bound) {
					nameBadge.title = 'Copiar nombre';
					nameBadge.addEventListener('click', async () => {
						const base = (nameBadge.dataset && nameBadge.dataset.base) ? nameBadge.dataset.base : (nameBadge.textContent || '').replace(/\s*‚úì+\s*$/g,'').trim();
						if (!base || base === '-') return;
						await copyToClipboard(base);
						// Silencioso: sin avisos visuales
					});
					nameBadge.dataset.bound = '1';
				}
				
				// Hacer el badge de notas editable (solo admin)
				if (adminNoteBadge && !adminNoteBadge.dataset.bound) {
					adminNoteBadge.title = 'Clic para editar nota';
					adminNoteBadge.style.cursor = 'pointer';
					adminNoteBadge.addEventListener('click', () => {
						if (currentUser.role !== 'admin' || !selectedUserKey) return;
						const currentNote = adminNotes[selectedUserKey] || '';
						const newNote = prompt('Nota para este usuario:', currentNote);
						if (newNote !== null) {
							saveAdminNote(selectedUserKey, newNote.trim());
						}
					});
					adminNoteBadge.dataset.bound = '1';
				}

				async function saveAdminNote(userKey, noteText) {
					if (!userKey || currentUser.role !== 'admin') return;
					try {
						adminNotes[userKey] = noteText;
						await setDoc(doc(fs, 'adminNotes', userKey), {
							note: noteText,
							updatedAt: fsServerTimestamp()
						});
						updateActiveChatHeader();
					} catch (err) {
						console.warn('No se pudo guardar la nota del admin', err);
					}
				}

				function appendMessage(id, msg, userKey) {
				const wrap = document.createElement('div');
				const roleVal = msg.r || msg.role;
				const senderVal = msg.s || msg.sender || 'An√≥nimo';
				const tsVal = msg.x || msg.ts;
				const textVal = msg.t || msg.text;
				const imageVal = msg.i || msg.imageDataUrl || msg.imageUrl;
				const audioVal = msg.a || msg.audioDataUrl;
				const pdfVal = msg.p || msg.pdfDataUrl || msg.pdfUrl;
				const nameVal = msg.n || msg.name;
				let typeVal = msg.type || msg.ty || msg.y || (imageVal ? 'i' : audioVal ? 'a' : pdfVal ? 'p' : textVal ? 't' : 't');
				if (typeof typeVal === 'string') {
					typeVal = typeVal.toLowerCase();
				}
				if (typeVal === 'image') typeVal = 'i';
				else if (typeVal === 'audio') typeVal = 'a';
				else if (typeVal === 'pdf') typeVal = 'p';
				else if (typeVal === 'text') typeVal = 't';
				const isMyMessage = (currentUser.role === 'admin' && roleVal === 'admin') || 
									(currentUser.role === 'user' && roleVal !== 'admin');
				wrap.className = 'msg ' + (isMyMessage ? 'from-admin' : 'from-user');
				if (id) {
					wrap.dataset.id = String(id);
					wrap.id = 'msg_' + String(id);
				}
				const meta = document.createElement('div');
				meta.className = 'meta';
				const shouldShowSenderName = roleVal !== 'admin';
				let name;
				if (shouldShowSenderName) {
					name = document.createElement('span');
					name.textContent = senderVal;
				}
				const role = document.createElement('span');
				role.className = 'role ' + (roleVal === 'admin' ? 'admin' : 'user');
				role.textContent = roleVal === 'admin' ? 'Admin' : 'Usuario';
				const time = document.createElement('span');
				const d = tsVal ? new Date(tsVal) : new Date();
				time.textContent = formatDateTime24(d);
				if (shouldShowSenderName && name) meta.appendChild(name);
				meta.appendChild(role);
				meta.appendChild(time);
				wrap.appendChild(meta);
				if (typeVal === 'i' && imageVal) {
					const imgWrap = document.createElement('div');
					imgWrap.className = 'image-msg bubble';
					if (msg.isSticker) {
						imgWrap.classList.add('sticker-msg');
					}
					const img = document.createElement('img');
					img.loading = 'lazy';
					img.decoding = 'async';
					img.src = imageVal;
					img.alt = 'imagen enviada';
					img.addEventListener('click', (e) => {
						e.preventDefault();
						e.stopPropagation();
						openImageDialog(img.src);
					});
					imgWrap.appendChild(img);
					wrap.appendChild(imgWrap);
				}
				if (typeVal === 'a' && audioVal) {
					const aWrap = document.createElement('div');
					aWrap.className = 'audio-msg bubble';
					const audio = document.createElement('audio');
					audio.controls = true;
					audio.src = audioVal;
					aWrap.appendChild(audio);
					wrap.appendChild(aWrap);
				}
				if (typeVal === 'p' && pdfVal) {
					const haveUrl = !!pdfVal;
					const fileWrap = document.createElement('div');
					fileWrap.className = 'file-msg bubble';
					const icon = document.createElement('div');
					icon.className = 'file-icon';
					icon.textContent = 'üìÑ';
					const details = document.createElement('div');
					details.className = 'file-details';
					const link = document.createElement('a');
					link.target = '_blank';
					link.rel = 'noopener';
					link.textContent = nameVal || 'Documento PDF';
					link.href = haveUrl ? pdfVal : '#';
					if (haveUrl) link.download = nameVal || 'documento.pdf';
					details.appendChild(link);
					const meta = document.createElement('div');
					meta.className = 'file-meta';
					meta.textContent = haveUrl ? '' : 'Subiendo PDF...';
					details.appendChild(meta);
					fileWrap.appendChild(icon);
					fileWrap.appendChild(details);
					wrap.appendChild(fileWrap);
				}
				if (typeVal === 't' && textVal) {
					const text = document.createElement('div');
					text.className = 'text bubble';
					const raw = (textVal || '').trim();
					if (/^https?:\/\/\S+/i.test(raw)) {
						const a = document.createElement('a');
						a.href = raw;
						a.textContent = raw;
						a.style.color = 'var(--primary)';
						a.addEventListener('click', (e) => {
							e.preventDefault();
							window.location.replace(a.href);
						});
						text.appendChild(a);
					} else {
						text.textContent = raw;
					}
					wrap.appendChild(text);
				}
				// Reacci√≥n (coraz√≥n) si corresponde
				if (msg.reactionHeart) {
					const r = document.createElement('div');
					r.className = 'reaction-heart';
					r.textContent = '‚ù§Ô∏è';
					wrap.appendChild(r);
				}
				// Bot√≥n de eliminar (solo para mensajes de admin, visible solo para admin)
				if (currentUser.role === 'admin' && roleVal === 'admin') {
					const deleteBtn = document.createElement('button');
					deleteBtn.className = 'delete-message-btn';
					deleteBtn.textContent = 'üóëÔ∏è';
					deleteBtn.title = 'Eliminar mensaje';
					deleteBtn.style.display = 'flex';
					deleteBtn.addEventListener('click', (e) => {
						e.stopPropagation();
						if (confirm('¬øEliminar este mensaje? Se borrar√° para todos los usuarios.')) {
							deleteMessage(String(id), userKey);
						}
					});
					wrap.appendChild(deleteBtn);
				}
				// Toggle reacci√≥n con clic derecho
				wrap.addEventListener('contextmenu', (e) => {
					e.preventDefault();
					if (!id) return;
					toggleMessageReaction(String(id));
				});
				
				// Copiar mensaje al mantener presionado (solo para usuarios en mensajes del admin)
				if (currentUser.role === 'user' && roleVal === 'admin') {
					let pressTimer = null;
					let touchStarted = false;
					
					const startPress = (e) => {
						touchStarted = true;
						wrap.classList.add('pressing');
						pressTimer = setTimeout(() => {
							if (touchStarted) {
								copyMessageToClipboard(wrap, textVal || '');
							}
						}, 500); // 500ms = medio segundo
					};
					
					const cancelPress = () => {
						touchStarted = false;
						wrap.classList.remove('pressing');
						if (pressTimer) {
							clearTimeout(pressTimer);
							pressTimer = null;
						}
					};
					
					// Touch events (m√≥vil)
					wrap.addEventListener('touchstart', startPress, { passive: true });
					wrap.addEventListener('touchend', cancelPress);
					wrap.addEventListener('touchcancel', cancelPress);
					wrap.addEventListener('touchmove', cancelPress);
					
					// Mouse events (escritorio, para testing)
					wrap.addEventListener('mousedown', startPress);
					wrap.addEventListener('mouseup', cancelPress);
					wrap.addEventListener('mouseleave', cancelPress);
				}
				
				// Guardar ts para ordenamiento estable en el DOM
				wrap.dataset.ts = String(msg.ts || 0);
				// Insertar en el lugar correcto por ts (asc)
				const ts = Number(wrap.dataset.ts || '0');
				let inserted = false;
				let node = messagesEl.lastElementChild;
				while (node && Number(node.dataset.ts || '0') > ts) {
					node = node.previousElementSibling;
				}
				if (!node) {
					messagesEl.insertBefore(wrap, messagesEl.firstElementChild);
					inserted = true;
				} else {
					// Insertar despu√©s del √∫ltimo menor o igual
					messagesEl.insertBefore(wrap, node.nextElementSibling);
					inserted = (node === messagesEl.lastElementChild);
				}
				// Auto-scroll siempre al final al agregar mensajes
				messagesEl.scrollTop = messagesEl.scrollHeight;
			}

			function appendMessageOnce(uniqueId, msg, userKey) {
				if (!uniqueId) {
					uniqueId = (msg && msg.ts ? String(msg.ts) : String(Date.now())) + '|' + (msg && msg.text ? msg.text.slice(0,32) : '')
				}
				if (renderedMessageIds.has(uniqueId)) return;
				renderedMessageIds.add(uniqueId);
				messageIndex.set(uniqueId, { msg, userKey });
				appendMessage(uniqueId, msg, userKey);
			}



			// Toggle de reacci√≥n (coraz√≥n) y actualizaci√≥n en BD y UI
			function updateReactionDom(uniqueId, reacted) {
				const el = document.getElementById('msg_' + String(uniqueId));
				if (!el) return;
				let node = el.querySelector('.reaction-heart');
				if (reacted) {
					if (!node) {
						node = document.createElement('div');
						node.className = 'reaction-heart';
						node.textContent = '‚ù§Ô∏è';
						el.appendChild(node);
					}
				} else {
					if (node) node.remove();
				}
			}

			function copyMessageToClipboard(messageElement, text) {
				if (!text || !text.trim()) return;
				
				// Copiar al portapapeles
				const copyText = text.trim();
				
				// M√©todo moderno (Clipboard API)
				if (navigator.clipboard && navigator.clipboard.writeText) {
					navigator.clipboard.writeText(copyText).then(() => {
						showCopyTooltip(messageElement);
					}).catch(() => {
						// Fallback si falla
						fallbackCopy(copyText, messageElement);
					});
				} else {
					// Fallback para navegadores antiguos
					fallbackCopy(copyText, messageElement);
				}
			}
			
			function fallbackCopy(text, messageElement) {
				try {
					const textarea = document.createElement('textarea');
					textarea.value = text;
					textarea.style.position = 'fixed';
					textarea.style.opacity = '0';
					document.body.appendChild(textarea);
					textarea.select();
					document.execCommand('copy');
					document.body.removeChild(textarea);
					showCopyTooltip(messageElement);
				} catch (err) {
					console.error('Error al copiar:', err);
				}
			}
			
			function showCopyTooltip(messageElement) {
				// Crear tooltip
				const tooltip = document.createElement('div');
				tooltip.className = 'copy-tooltip';
				tooltip.textContent = 'Mensaje copiado';
				
				// Agregar al mensaje
				messageElement.appendChild(tooltip);
				
				// Remover despu√©s de la animaci√≥n (2.3s)
				setTimeout(() => {
					if (tooltip.parentElement) {
						tooltip.remove();
					}
				}, 2300);
			}

			function updatePdfDom(uniqueId, msg) {
				const el = document.getElementById('msg_' + String(uniqueId));
				if (!el) return;
				let fileWrap = el.querySelector('.file-msg');
				const haveUrl = !!(msg.pdfUrl || msg.pdfDataUrl);
				if (!fileWrap && (msg.type === 'pdf')) {
					fileWrap = document.createElement('div');
					fileWrap.className = 'file-msg bubble';
					const icon = document.createElement('div');
					icon.className = 'file-icon';
					icon.textContent = 'üìÑ';
					const details = document.createElement('div');
					details.className = 'file-details';
					const link = document.createElement('a');
					link.textContent = msg.name || 'Documento PDF';
					link.target = '_blank';
					link.rel = 'noopener';
					link.href = haveUrl ? (msg.pdfUrl || msg.pdfDataUrl) : '#';
					if (haveUrl) link.download = msg.name || 'documento.pdf';
					details.appendChild(link);
					const meta = document.createElement('div');
					meta.className = 'file-meta';
					meta.textContent = (typeof msg.size === 'number' && msg.size > 0) ? formatFileSize(msg.size) : (haveUrl ? '' : 'Subiendo PDF...');
					details.appendChild(meta);
					fileWrap.appendChild(icon);
					fileWrap.appendChild(details);
					el.appendChild(fileWrap);
					return;
				}
				if (fileWrap) {
					const link = fileWrap.querySelector('a') || (() => { const a = document.createElement('a'); a.target = '_blank'; a.rel = 'noopener'; fileWrap.querySelector('.file-details')?.appendChild(a); return a; })();
					if (haveUrl) {
						link.href = msg.pdfUrl || msg.pdfDataUrl;
						link.download = msg.name || 'documento.pdf';
						const meta = fileWrap.querySelector('.file-meta');
						if (meta && (!meta.textContent || /Subiendo/i.test(meta.textContent))) meta.textContent = (typeof msg.size === 'number' && msg.size > 0) ? formatFileSize(msg.size) : '';
					}
				}
			}

			function handleChildChanged(uniqueId, newMsg, userKey) {
				messageIndex.set(uniqueId, { msg: newMsg, userKey });
				if ('reactionHeart' in newMsg) {
					updateReactionDom(uniqueId, !!newMsg.reactionHeart);
				}
				if (newMsg && newMsg.type === 'pdf') {
					updatePdfDom(uniqueId, newMsg);
				}
			}

			async function toggleMessageReaction(uniqueId) {
				try {
					if (!uniqueId) return;
					const info = messageIndex.get(uniqueId);
					if (!info) return;
					const { msg, userKey } = info;
					const newVal = !msg.reactionHeart;
					// RTDB: actualizar campo reactionHeart
					try {
						await update(ref(db, `chat/conversaciones/${userKey}/${uniqueId}`), { reactionHeart: newVal });
					} catch (err) {
						console.warn('No se pudo actualizar reacci√≥n en RTDB:', err);
					}
					// UI local
					msg.reactionHeart = newVal;
					updateReactionDom(uniqueId, newVal);
					// Firestore: intentar actualizar por id directo; si falla, buscar por rtdbKey
					try {
						await setDoc(doc(fs, 'mensajes', uniqueId), { reactionHeart: newVal, updatedAt: fsServerTimestamp() }, { merge: true });
					} catch (err1) {
						try {
							const colRef = collection(fs, 'mensajes');
							const q = fsQuery(colRef, where('rtdbKey', '==', uniqueId), where('userKeyNormalized', '==', (userKey || '').toLowerCase()));
							const snap = await getDocs(q);
							if (!snap.empty) {
								const batch = writeBatch(fs);
								snap.forEach(d => batch.update(d.ref, { reactionHeart: newVal, updatedAt: fsServerTimestamp() }));
								await batch.commit();
							}
						} catch (err2) {
							console.warn('No se pudo actualizar reacci√≥n en Firestore:', err2);
						}
					}
				} catch (err) {
					console.error('Error alternando reacci√≥n:', err);
				}
			}

			async function deleteMessage(uniqueId, userKey) {
				try {
					if (!uniqueId || !userKey) return;
					
					// 1. Eliminar del DOM
					const msgElement = document.getElementById('msg_' + uniqueId);
					if (msgElement) {
						msgElement.remove();
					}
					
					// 2. Eliminar del √≠ndice local
					renderedMessageIds.delete(uniqueId);
					messageIndex.delete(uniqueId);
					
					// 3. Eliminar de RTDB
					try {
						await remove(ref(db, `chat/conversaciones/${userKey}/${uniqueId}`));
					} catch (err) {
						console.warn('No se pudo eliminar mensaje de RTDB:', err);
					}
					
					// 4. Eliminar de Firestore (intentar por id directo primero, luego por rtdbKey)
					try {
						await deleteDoc(doc(fs, 'mensajes', uniqueId));
					} catch (err1) {
						try {
							const colRef = collection(fs, 'mensajes');
							const q = fsQuery(colRef, where('rtdbKey', '==', uniqueId), where('userKeyNormalized', '==', (userKey || '').toLowerCase()));
							const snap = await getDocs(q);
							if (!snap.empty) {
								const batch = writeBatch(fs);
								snap.forEach(d => batch.delete(d.ref));
								await batch.commit();
							}
						} catch (err2) {
							console.warn('No se pudo eliminar mensaje de Firestore:', err2);
						}
					}
					
					console.log('Mensaje eliminado correctamente:', uniqueId);
				} catch (err) {
					console.error('Error eliminando mensaje:', err);
					alert('No se pudo eliminar el mensaje. Intenta de nuevo.');
				}
			}

			function clearChat() {
							messagesEl.innerHTML = '';
							renderedMessageIds = new Set();
							messageIndex = new Map();
						try { if (pdfPreview) pdfPreview.style.display = 'none'; } catch {}
							if (chatListener) {
								try { off(chatListener.ref, 'child_added', chatListener.callback); } catch {}
								chatListener = null;
							}
							if (unsubscribeHistoryFS) {
								try { unsubscribeHistoryFS(); } catch {}
								unsubscribeHistoryFS = null;
							}
							if (messagesScrollHandler) {
								messagesEl.removeEventListener('scroll', messagesScrollHandler);
								messagesScrollHandler = null;
							}
			}
			
			function loadChat(userKey) {
			clearChat();
			if (!userKey) {
				updateActiveChatHeader();
				// Sin chat seleccionado: ocultar vistas previas pendientes en UI
				try { if (imagePreview) imagePreview.style.display = 'none'; } catch {}
				try { if (audioPreview) audioPreview.style.display = 'none'; } catch {}
				try { if (pdfPreview) pdfPreview.style.display = 'none'; } catch {}
				return;
			}

			const convRef = ref(db, 'chat/conversaciones/' + userKey);
			const INITIAL_MESSAGE_LIMIT = 25;
			subscribeFirestoreHistory(userKey);
			const convQuery = query(convRef, orderByChild('ts'), limitToLast(INITIAL_MESSAGE_LIMIT));
			const childAddedHandler = (snap) => {
				const val = snap.val() || {};
				if (!val.ts && val.timestamp) val.ts = val.timestamp;
				appendMessageOnce(snap.key, val, userKey);
				handleNewMessage(userKey, val);
			};
			onChildAdded(convQuery, childAddedHandler);
			chatListener = { ref: convQuery, callback: childAddedHandler };
			onChildChanged(convQuery, (snap) => {
				const val = snap.val() || {};
				if (!val.ts && val.timestamp) val.ts = val.timestamp;
				handleChildChanged(snap.key, val, userKey);
			});

			const messagesEl = document.getElementById('messages');
			if (!messagesEl) return;
			selectedUserKey = userKey;
			let isLoadingOldMessages = false;

			const scrollHandler = async () => {
				if (messagesEl.scrollTop === 0 && !isLoadingOldMessages) {
				isLoadingOldMessages = true;

				const first = messagesEl.firstElementChild;
				const oldestTs = first ? Number(first.dataset.ts || '0') : 0;
				if (!oldestTs) {
					isLoadingOldMessages = false;
					return;
				}

				try {
					const moreQuery = query(convRef, orderByChild('ts'), endAt(oldestTs - 1), limitToLast(INITIAL_MESSAGE_LIMIT));
					const snapshot = await get(moreQuery);
					const data = snapshot.val() || {};
					const entries = Object.entries(data).sort((a, b) => {
						const aTs = Number((a[1] && (a[1].ts || a[1].timestamp)) || 0);
						const bTs = Number((b[1] && (b[1].ts || b[1].timestamp)) || 0);
						return aTs - bTs;
					});
					for (const [key, val] of entries) {
						if (!val.ts && val.timestamp) val.ts = val.timestamp;
						if (!renderedMessageIds.has(key)) {
							appendMessageOnce(key, val, userKey);
						}
					}
				} catch (err) {
					console.error("Error cargando mensajes antiguos:", err);
				}

				isLoadingOldMessages = false;
				}
			};
			messagesEl.addEventListener('scroll', scrollHandler);
			messagesScrollHandler = scrollHandler;
			clearUnread(userKey);
			// Marcar como le√≠do persistentemente al abrir el chat (solo admin)
			if (currentUser.role === 'admin') {
				markChatRead(userKey);
			}
			updateActiveChatHeader();
			// Gestionar visibilidad de vistas previas seg√∫n el chat due√±o
			try {
				if (pendingAudioDataUrl) {
					if (audioPreviewOwnerKey === userKey) {
						showAudioPreview(pendingAudioDataUrl, pendingAudioSizeKB || 0);
					} else if (audioPreview) {
						audioPreview.style.display = 'none';
					}
				}
				if (pendingImageFile) {
					if (imagePreviewOwnerKey === userKey) {
						showImagePreview(pendingImageFile);
					} else if (imagePreview) {
						imagePreview.style.display = 'none';
					}
				}
				if (pendingPdfFile) {
					if (pdfPreviewOwnerKey === userKey) {
						showPdfPreview(pendingPdfFile);
					} else if (pdfPreview) {
						pdfPreview.style.display = 'none';
					}
				}
			} catch {}
			}

			async function upsertConversationMetadata(userKey, info = {}) {
				if (!userKey) return;
				// Determinar tipo del √∫ltimo contenido
				let type = info.type;
				if (!type) {
					if (info.text) type = 'text';
					else if (info.imageDataUrl) type = 'image';
					else if (info.audioDataUrl) type = 'audio';
					else if (info.pdfDataUrl) type = 'pdf';
					else if (info.name && /\.pdf$/i.test(info.name)) type = 'pdf';
					else type = 'text';
				}

				// Pol√≠tica: no guardar contenido de texto como preview ni tipificarlo como "text",
				// pero s√≠ crear/actualizar un documento m√≠nimo para que el admin vea la conversaci√≥n.
				// Para multimedia (imagen/audio/pdf), mantenemos un resumen b√°sico.
				let preview = null;
				if (type === 'image') {
					preview = info.name ? `üì∑ ${info.name}` : 'üì∑ Imagen enviada';
				} else if (type === 'audio') {
					preview = 'üé§ Audio enviado';
				} else if (type === 'pdf') {
					preview = info.name ? `üìÑ ${info.name}` : 'üìÑ PDF enviado';
				}
				const ts = typeof info.ts === 'number' ? info.ts : nowMs();
				const payload = {
					uk: userKey,
					hh: true,
					// No guardar texto como tipo "text" ni su preview
					lmt: (type === 'text') ? null : type,
					lmp: (type === 'text') ? '' : preview,
					lmts: ts,
					ls: info.sender || null,
					lsr: info.role || null,
					ua: fsServerTimestamp()
				};
				try {
					await setDoc(doc(fs, 'conversaciones', userKey), payload, { merge: true });
					conversationMeta[userKey] = { ...(conversationMeta[userKey] || {}), ...payload };
					if (currentUser.role === 'admin') {
						renderUserList();
					}
				} catch (err) {
					console.warn('No se pudo actualizar metadata de conversaci√≥n:', err);
				}
			}
		async function sendTextToCurrentChat(text) {
			const trimmed = (text || '').trim();
			if (!trimmed) return;
			let userChatKey = null;
			if (currentUser.role === 'admin') {
				if (!selectedUserKey) return;
				userChatKey = selectedUserKey;
			} else {
				userChatKey = currentUser.name;
			}
			if (!userChatKey) return;
			const convRef = ref(db, 'chat/conversaciones/' + userChatKey);
			const payload = {
				t: trimmed, // texto
				s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo', // sender
				r: currentUser.role, // role
				x: nowMs(), // timestamp
				y: 't' // tipo texto
			};
			const newRef = push(convRef);
			await set(newRef, payload);
			// NO archivar texto en Firestore
			appendMessageOnce(newRef.key, payload, userChatKey);
			try {
				await upsertConversationMetadata(userChatKey, {
					type: 'text',
					text: trimmed,
					sender: payload.s,
					role: payload.r,
					ts: payload.x
				});
			} catch (err) {
				console.warn('No se pudo actualizar metadata de conversaci√≥n (texto):', err);
			}
		}

		async function sendCurrentMessage() {
			const raw = messageInput.value;
			const text = raw.trim();
			if (!text) return;
			messageInput.value = '';
			messageInput.focus();
			try {
				await sendTextToCurrentChat(text);
			} catch (err) {
				console.warn('No se pudo enviar el mensaje de texto:', err);
				messageInput.value = raw;
				messageInput.focus();
				alert('No se pudo enviar el mensaje. Intentalo de nuevo');
			}
		}

			function isImage(file) {
				if (!file) return false;
				const type = (file.type || '').toLowerCase();
				const name = (file.name || '').toLowerCase();
				if (type.startsWith('video/')) return false;
				if (type === 'image/gif' || /\.gif$/i.test(name)) return false;
				const okMime = type.startsWith('image/') && type !== 'image/gif';
				const okExt = /\.(jpe?g|png|webp|bmp)$/i.test(name);
				return okMime || okExt;
			}

			function isPdf(file) {
				if (!file) return false;
				const type = (file.type || '').toLowerCase();
				const name = (file.name || '').toLowerCase();
				return type === 'application/pdf' || /\.pdf$/i.test(name);
			}

			async function compressImageToDataURL(file, opts = {}) {
				const maxSize = opts.maxSize || 960;
				const quality = opts.quality || 0.75;
				const bgColor = opts.bgColor || '#ffffff';
				return new Promise((resolve, reject) => {
					try {
						const url = URL.createObjectURL(file);
						const img = new Image();
						img.onload = () => {
							try {
								const iw = img.naturalWidth || img.width;
								const ih = img.naturalHeight || img.height;
								let tw = iw;
								let th = ih;
								if (iw > ih && iw > maxSize) { th = Math.round(ih * (maxSize / iw)); tw = maxSize; }
								else if (ih >= iw && ih > maxSize) { tw = Math.round(iw * (maxSize / ih)); th = maxSize; }
								const canvas = document.createElement('canvas');
								canvas.width = tw; canvas.height = th;
								const ctx = canvas.getContext('2d');
								ctx.fillStyle = bgColor;
								ctx.fillRect(0, 0, tw, th);
								ctx.drawImage(img, 0, 0, tw, th);
								const dataUrl = canvas.toDataURL('image/jpeg', quality);
								URL.revokeObjectURL(url);
								resolve(dataUrl);
							} catch (e) {
								URL.revokeObjectURL(url);
								reject(e);
							}
						};
						img.onerror = () => {
							URL.revokeObjectURL(url);
							reject(new Error('No se pudo leer la imagen. Formato no soportado por el navegador'));
						};
						img.src = url;
					} catch (err) {
						reject(err);
					}
				});
			}

			async function convertImageToJPEGDataURL(file, opts = {}) {
				return await compressImageToDataURL(file, opts);
			}

			async function convertImageToJPEGFile(file, opts = {}) {
				const dataUrl = await compressImageToDataURL(file, opts);
				const blob = dataURLToBlob(dataUrl);
				const baseName = ((file && file.name) ? file.name : 'imagen').replace(/\.[^.]+$/, '');
				try {
					return new File([blob], baseName + '.jpg', { type: 'image/jpeg' });
				} catch (_) {
					blob.name = baseName + '.jpg';
					return blob;
				}
			}

				async function fileToDataUrl(file) {
					return new Promise((resolve, reject) => {
						try {
							const reader = new FileReader();
							reader.onload = () => resolve(reader.result || '');
							reader.onerror = () => reject(new Error('No se pudo leer el archivo'));
							reader.readAsDataURL(file);
						} catch (err) {
							reject(err);
						}
					});
				}

			function showImagePreview(file) {
				if (!file) return;
				// Determinar a qu√© chat pertenece esta vista previa
				let ownerKey = null;
				if (currentUser.role === 'admin') {
					if (!selectedUserKey) {
						alert('Primero seleccion√° un chat para adjuntar una imagen');
						return;
					}
					ownerKey = selectedUserKey;
				} else {
					ownerKey = currentUser.name;
				}
				imagePreviewOwnerKey = ownerKey;
				if (imagePreviewThumb.src && imagePreviewThumb.src.startsWith('blob:')) {
					try { URL.revokeObjectURL(imagePreviewThumb.src); } catch {}
				}
				pendingImageFile = file;
				const url = URL.createObjectURL(file);
				imagePreviewThumb.src = url;
				imagePreviewName.textContent = file.name || 'imagen';
				imagePreview.style.display = 'flex';
				messagesEl.scrollTop = messagesEl.scrollHeight;
				confirmImageBtn.disabled = false;
				cancelImageBtn.disabled = false;
			}

			function clearImagePreview() {
				if (imagePreviewThumb.src && imagePreviewThumb.src.startsWith('blob:')) {
					try { URL.revokeObjectURL(imagePreviewThumb.src); } catch {}
				}
				imagePreviewThumb.src = '';
				imagePreview.style.display = 'none';
				pendingImageFile = null;
				imagePreviewOwnerKey = null;
				uploadingImage = false;
				confirmImageBtn.disabled = false;
				cancelImageBtn.disabled = false;
			}

			function showPdfPreview(file) {
				if (!file) return;
				let ownerKey = null;
				if (currentUser.role === 'admin') {
					if (!selectedUserKey) {
						alert('Primero seleccion√° un chat para adjuntar un PDF');
						return;
					}
					ownerKey = selectedUserKey;
				} else {
					ownerKey = currentUser.name;
				}
				pdfPreviewOwnerKey = ownerKey;
				pendingPdfFile = file;
				if (pdfPreviewName) pdfPreviewName.textContent = file.name || 'documento.pdf';
				if (pdfPreviewSize) pdfPreviewSize.textContent = file.size ? formatFileSize(file.size) : '';
				if (pdfPreview) pdfPreview.style.display = 'flex';
				sendingPdf = false;
				confirmPdfBtn.disabled = false;
				cancelPdfBtn.disabled = false;
				messagesEl.scrollTop = messagesEl.scrollHeight;
			}

			function clearPdfPreview() {
				if (pdfPreview) pdfPreview.style.display = 'none';
				pendingPdfFile = null;
				pdfPreviewOwnerKey = null;
				sendingPdf = false;
				confirmPdfBtn.disabled = false;
				cancelPdfBtn.disabled = false;
				if (pdfPreviewSize) pdfPreviewSize.textContent = '';
				if (pdfPreviewName) pdfPreviewName.textContent = 'documento.pdf';
			}

			function showAudioPreview(dataUrl, sizeKB) {
				if (!audioPreview || !audioPreviewPlayer) return;
				// Registrar due√±o de la vista previa (chat actual)
				let ownerKey = null;
				if (currentUser.role === 'admin') {
					ownerKey = selectedUserKey || null;
				} else {
					ownerKey = currentUser.name || null;
				}
				audioPreviewOwnerKey = ownerKey;
				pendingAudioSizeKB = Number(sizeKB || 0);
				audioPreviewPlayer.pause();
				audioPreviewPlayer.src = dataUrl;
				try { audioPreviewPlayer.currentTime = 0; } catch {}
				audioPreviewName.textContent = `grabaci√≥n ~${sizeKB} KB`;
				audioPreview.style.display = 'flex';
				messagesEl.scrollTop = messagesEl.scrollHeight;
				confirmAudioBtn.disabled = false;
				cancelAudioBtn.disabled = false;
			}

			function clearAudioPreview() {
				if (!audioPreview) return;
				try { audioPreviewPlayer.pause(); } catch {}
				audioPreviewPlayer.removeAttribute('src');
				pendingAudioDataUrl = null;
				pendingAudioSizeKB = 0;
				audioPreview.style.display = 'none';
				confirmAudioBtn.disabled = false;
				cancelAudioBtn.disabled = false;
				sendingAudio = false;
				audioPreviewOwnerKey = null;
			}

			function formatDuration(ms) {
				const total = Math.floor(ms / 1000);
				const m = String(Math.floor(total / 60)).padStart(2, '0');
				const s = String(total % 60).padStart(2, '0');
				return `${m}:${s}`;
			}

			function formatFileSize(bytes) {
				if (typeof bytes !== 'number' || Number.isNaN(bytes) || bytes < 0) return '';
				const units = ['B', 'KB', 'MB', 'GB'];
				let value = bytes;
				let unitIndex = 0;
				while (value >= 1024 && unitIndex < units.length - 1) {
					value /= 1024;
					unitIndex++;
				}
				const formatted = unitIndex === 0 ? Math.round(value).toString() : value.toFixed(1);
				return `${formatted} ${units[unitIndex]}`;
			}

			function startRecordingTimer() {
				recordingStartedAt = Date.now();
				recordingTimeEl.textContent = '00:00';
				recordingBar.style.display = 'flex';
				recordingTimer = setInterval(() => {
					recordingTimeEl.textContent = formatDuration(Date.now() - recordingStartedAt);
				}, 200);
			}

			function stopRecordingTimer() {
				if (recordingTimer) { clearInterval(recordingTimer); recordingTimer = null; }
				recordingBar.style.display = 'none';
			}

			async function ensureMicStream() {
				return await navigator.mediaDevices.getUserMedia({ audio: true });
			}

			function onAudioDataAvailable(e) {
				if (e.data && e.data.size > 0) audioChunks.push(e.data);
			}

		async function startAudioRecording() {
		try {
			const stream = await ensureMicStream();
			audioChunks = [];
			mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

			mediaRecorder.ondataavailable = onAudioDataAvailable;

			mediaRecorder.onstop = async () => {
			stream.getTracks().forEach(t => t.stop());
			const blob = new Blob(audioChunks, { type: 'audio/webm' });
			const sizeKB = Math.round(blob.size / 1024);

			if (sizeKB < 3) { 
				console.warn('Audio muy corto, no se prepara vista previa');
				mediaRecorder = null; 
				audioChunks = []; 
				return; 
			}

			const reader = new FileReader();
			reader.onloadend = async () => {
				pendingAudioDataUrl = String(reader.result || '');
				if (pendingAudioDataUrl) {
					showAudioPreview(pendingAudioDataUrl, sizeKB);
				}
				mediaRecorder = null;
				audioChunks = [];
			};
			reader.readAsDataURL(blob);
			};

			mediaRecorder.start();
			startRecordingTimer();
			setTimeout(() => {
			if (mediaRecorder && mediaRecorder.state === 'recording') stopAudioRecording(true);
			}, 60000);

		} catch (err) {
			alert('No se pudo acceder al micr√≥fono. Revis√° permisos del navegador');
		}
		}

			async function stopAudioRecording(auto = false) {
				if (!mediaRecorder) return;
				if (mediaRecorder.state === 'recording') {
					try { mediaRecorder.stop(); } catch {}
				}
				stopRecordingTimer();
			}

			async function sendAudioMessage(audioDataUrl) {
				let userChatKey = null;
				if (currentUser.role === 'admin') {
					if (!selectedUserKey) return;
					userChatKey = selectedUserKey;
				} else {
					userChatKey = currentUser.name;
				}
				if (!userChatKey) return;
				const now = nowMs();
				try {
					const docRef = await addDoc(collection(fs, 'mensajes'), {
						a: audioDataUrl,
						s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
						r: currentUser.role,
						x: now,
						y: 'a',
						userKey: userChatKey,
						userKeyNormalized: (userChatKey || '').toLowerCase(),
						createdAt: fsServerTimestamp()
					});
					appendMessageOnce(docRef.id, {
						a: audioDataUrl,
						s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
						r: currentUser.role,
						x: now,
						y: 'a'
					}, userChatKey);
				} catch (e) { console.warn('No se pudo guardar audio en Firestore:', e); }
				try {
					await upsertConversationMetadata(userChatKey, {
						type: 'audio',
						sender: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
						role: currentUser.role,
						ts: now
					});
				} catch (err) {
					console.warn('No se pudo actualizar metadata de conversaci√≥n (audio):', err);
				}
			}

			audioBtn.addEventListener('mousedown', (e) => { e.preventDefault(); startAudioRecording(); });
			audioBtn.addEventListener('mouseup', (e) => { e.preventDefault(); stopAudioRecording(); });
			audioBtn.addEventListener('mouseleave', (e) => { if (mediaRecorder && mediaRecorder.state === 'recording') stopAudioRecording(); });
			audioBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startAudioRecording(); }, { passive: false });
			audioBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopAudioRecording(); }, { passive: false });
			async function uploadImageAndSend(file) {
				try {
					if (!isImage(file)) return;
					uploadingImage = true;
					confirmImageBtn.disabled = true;
					cancelImageBtn.disabled = true;
					let userChatKey = null;
					if (currentUser.role === 'admin') {
						if (!selectedUserKey) return;
						userChatKey = selectedUserKey;
					} else {
						userChatKey = currentUser.name;
					}
					if (!userChatKey) return;
					const dataUrl = await compressImageToDataURL(file, { maxSize: 960, quality: 0.70 });
					const approxBytes = Math.ceil((dataUrl.length - 'data:image/jpeg;base64,'.length) * 3 / 4);
					if (approxBytes > 700 * 1024) {
						throw new Error('La imagen es muy pesada');
					}
					const now = nowMs();
					try {
						const docRef = await addDoc(collection(fs, 'mensajes'), {
							i: dataUrl,
							n: file.name || null,
							s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
							r: currentUser.role,
							x: now,
							y: 'i',
							userKey: userChatKey,
							userKeyNormalized: (userChatKey || '').toLowerCase(),
							createdAt: fsServerTimestamp()
						});
						appendMessageOnce(docRef.id, {
							i: dataUrl,
							n: file.name || null,
							s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
							r: currentUser.role,
							x: now,
							y: 'i'
						}, userChatKey);
					} catch (e) {
						console.warn('No se pudo guardar imagen en Firestore:', e);
					}
					try {
						await upsertConversationMetadata(userChatKey, {
							type: 'image',
							name: file.name || null,
							sender: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
							role: currentUser.role,
							ts: now
						});
					} catch (err) {
						console.warn('No se pudo actualizar metadata de conversaci√≥n (imagen):', err);
					}
					clearImagePreview();
				} catch (err) {
					console.error('Error subiendo imagen', err);
					const msg = (err && err.message) ? err.message : 'No se pudo enviar la imagen';
					alert(msg);
					uploadingImage = false;
					confirmImageBtn.disabled = false;
					cancelImageBtn.disabled = false;
				}
			}

			async function sendPdfAttachment(file) {
				if (!isPdf(file)) return;
				if (file.size && file.size > 2 * 1024 * 1024) {
					throw new Error('El PDF es muy pesado (m√°x 2 MB)');
				}
				let userChatKey = null;
				if (currentUser.role === 'admin') {
					if (!selectedUserKey) return;
					userChatKey = selectedUserKey;
				} else {
					userChatKey = currentUser.name;
				}
				if (!userChatKey) return;
				try {
					const dataUrl = await fileToDataUrl(file);
					const now = nowMs();
					const docRef = await addDoc(collection(fs, 'mensajes'), {
						p: dataUrl,
						n: file.name || null,
						s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
						r: currentUser.role,
						x: now,
						y: 'p',
						userKey: userChatKey,
						userKeyNormalized: (userChatKey || '').toLowerCase(),
						createdAt: fsServerTimestamp()
					});
					appendMessageOnce(docRef.id, {
						p: dataUrl,
						n: file.name || null,
						s: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
						r: currentUser.role,
						x: now,
						y: 'p'
					}, userChatKey);
					await upsertConversationMetadata(userChatKey, {
						type: 'pdf',
						name: file.name || null,
						sender: currentUser.role === 'admin' ? 'Administrador' : currentUser.name || 'An√≥nimo',
						role: currentUser.role,
						ts: now
					});
				} catch (err) {
					console.error('Error preparando/enviando PDF:', err);
					throw err;
				}
			}

			imageBtn.addEventListener('click', () => imageInput.click());
			imageInput.addEventListener('change', (e) => {
				const file = e.target.files && e.target.files[0];
				if (file) {
					if (!isImage(file)) {
						alert('Solo se permiten im√°genes (JPG, PNG, WEBP, HEIC) GIF y videos no est√°n permitidos');
					} else {
						if (uploadingImage) return;
						showImagePreview(file);
					}
				}
				imageInput.value = '';
			});

			pdfBtn.addEventListener('click', () => pdfInput.click());
			pdfInput.addEventListener('change', (e) => {
				const file = e.target.files && e.target.files[0];
				if (file) {
					if (!isPdf(file)) {
						alert('Solo se permiten archivos PDF');
					} else if (file.size && file.size > 2 * 1024 * 1024) {
						alert('El PDF es muy pesado (m√°x 2 MB)');
					} else {
						if (sendingPdf) return;
						showPdfPreview(file);
					}
				}
				pdfInput.value = '';
			});

			// Paste handler (desktop)
			document.addEventListener('paste', (e) => {
				if (!e.clipboardData) return;
				const items = Array.from(e.clipboardData.items || []);
				const fileItem = items.find(i => i.kind === 'file');
				if (fileItem) {
					const file = fileItem.getAsFile();
					if (file) {
						if (!isImage(file)) {
							alert('Solo se permiten im√°genes (JPG, PNG, WEBP, HEIC) GIF y videos no est√°n permitidos');
						} else {
							if (uploadingImage) return;
							showImagePreview(file);
						}
					}
				}
			});

			// Drag & drop (desktop)
			const dropTargets = [messagesEl, document.body];
			dropTargets.forEach(el => {
				el.addEventListener('dragover', (e) => { e.preventDefault(); });
				el.addEventListener('drop', (e) => {
					e.preventDefault();
					const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
					if (file) {
						if (!isImage(file)) {
							alert('Solo se permiten im√°genes (JPG, PNG, WEBP, HEIC) GIF y videos no est√°n permitidos');
						} else {
							if (uploadingImage) return;
							showImagePreview(file);
						}
					}
				});
			});

			// Confirm/Cancel image
			confirmImageBtn.addEventListener('click', async () => {
				if (pendingImageFile && !uploadingImage) {
					// Validar que seguimos en el chat due√±o de la vista previa
					let currentKey = currentUser.role === 'admin' ? selectedUserKey : currentUser.name;
					if (imagePreviewOwnerKey && currentKey !== imagePreviewOwnerKey) {
						alert('Cambiaste de chat. Volv√© al chat original para enviar esta imagen, o cancel√° y adjuntala de nuevo.');
						return;
					}
					await uploadImageAndSend(pendingImageFile);
				}
			});
			cancelImageBtn.addEventListener('click', () => {
				if (uploadingImage) return;
				clearImagePreview();
			});

			confirmPdfBtn.addEventListener('click', async () => {
				if (!pendingPdfFile || sendingPdf) return;
				let currentKey = currentUser.role === 'admin' ? selectedUserKey : currentUser.name;
				if (pdfPreviewOwnerKey && currentKey !== pdfPreviewOwnerKey) {
					alert('Cambiaste de chat. Volv√© al chat original para enviar este PDF, o cancel√° y adjuntalo de nuevo.');
					return;
				}
				sendingPdf = true;
				confirmPdfBtn.disabled = true;
				cancelPdfBtn.disabled = true;
				try {
					await sendPdfAttachment(pendingPdfFile);
					clearPdfPreview();
				} catch (err) {
					console.error('Error al enviar PDF:', err);
					const msg = (err && err.message) ? err.message : 'No se pudo enviar el PDF';
					alert(msg);
					sendingPdf = false;
					confirmPdfBtn.disabled = false;
					cancelPdfBtn.disabled = false;
				}
			});
			cancelPdfBtn.addEventListener('click', () => {
				if (sendingPdf) return;
				clearPdfPreview();
			});

			// Confirm/Cancel audio
			confirmAudioBtn.addEventListener('click', async () => {
				if (!pendingAudioDataUrl || sendingAudio) return;
				// Validar que seguimos en el chat due√±o de la vista previa
				let currentKey = currentUser.role === 'admin' ? selectedUserKey : currentUser.name;
				if (audioPreviewOwnerKey && currentKey !== audioPreviewOwnerKey) {
					alert('Cambiaste de chat. Volv√© al chat original para enviar este audio, o cancel√° y grab√° de nuevo.');
					return;
				}
				sendingAudio = true;
				confirmAudioBtn.disabled = true;
				cancelAudioBtn.disabled = true;
				try {
					await sendAudioMessage(pendingAudioDataUrl);
					clearAudioPreview();
				} catch (err) {
					console.error('Error al enviar audio:', err);
					alert('No se pudo subir el audio');
					sendingAudio = false;
					confirmAudioBtn.disabled = false;
					cancelAudioBtn.disabled = false;
				}
			});
			cancelAudioBtn.addEventListener('click', () => {
				if (sendingAudio) return;
				clearAudioPreview();
			});

			sendBtn.addEventListener('click', sendCurrentMessage);
			messageInput.addEventListener('keydown', (e) => {
				if (e.key === 'Enter') {
					e.preventDefault();
					sendCurrentMessage();
				}
			});

			// Forzar que cualquier clickeado dentro del √°rea de mensajes navegue en la misma pesta√±a (accesos)
			messagesEl.addEventListener('click', (e) => {
				const a = e.target && e.target.closest ? e.target.closest('a') : null;
				if (a && a.href && /^https?:\/\//i.test(a.href)) {
					e.preventDefault();
					window.location.replace(a.href);
				}
			});

			if (shortcutGanamos) {
				shortcutGanamos.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('https://www.ganamos.pw/');
				});
			}

			if (shortcutZeus) {
				shortcutZeus.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('https://www.casinozeus26.com/');
				});
			}

			if (shortcutBet30) {
				shortcutBet30.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('https://www.bet30.gold/');
				});
			}

			if (shortcutCamel) {
				shortcutCamel.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('https://www.camelbet24.com/');
				});
			}

			if (shortcutGnaCsa) {
				shortcutGnaCsa.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('http://ganaencasa24.com/');
				});
			}

			if (shortcutCelu) {
				shortcutCelu.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('https://www.celuapuestas24.ws/');
				});
			}

			if (shortcutFortu) {
				shortcutFortu.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('http://fortubet24.ws/');
				});
			}

			if (shortcutArgen) {
				shortcutArgen.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('https://argenbet.net/');
				});
			}

			if (shortcutPoseidon) {
				shortcutPoseidon.addEventListener('click', async () => {
					if (currentUser.role !== 'admin') return;
					if (!selectedUserKey) {
						return;
					}
					await sendTextToCurrentChat('https://granposeidon.eu/');
				});
			}

			// Paneles: navegaci√≥n directa
			if (panelG32) {
				panelG32.addEventListener('click', () => {
					try { window.open('https://bo.casinoenvivo.club/login', '_blank', 'noopener,noreferrer'); } catch {}
				});
			}
			if (panelGnmos) {
				panelGnmos.addEventListener('click', () => {
					try { window.open('https://bo.ganamos.pw/login', '_blank', 'noopener,noreferrer'); } catch {}
				});
			}
			if (panelArgen) {
				panelArgen.addEventListener('click', () => {
					try { window.open('https://admin.argenbet.net/users/all', '_blank', 'noopener,noreferrer'); } catch {}
				});
			}

			// Cajero: configurar sonido de notificaciones (solo admin)
			if (btnCajeroSound) {
				btnCajeroSound.addEventListener('click', () => {
					if (currentUser.role !== 'admin') return;
					updateSoundStatusLabel();
					try { soundDialog.showModal(); } catch { soundDialog.open = true; }
				});
			}

			if (btnCajeroSupport) {
				btnCajeroSupport.addEventListener('click', () => {
					if (currentUser.role !== 'admin') return;
					alert(SUPPORT_WHATSAPP_MESSAGE);
				});
			}

			function attemptOpenNotificationSettings() {
				if (typeof window === 'undefined') return false;
				try {
					const ua = (navigator.userAgent || '').toLowerCase();
					const mappings = [
						{ match: (u) => u.includes('edg'), url: 'edge://settings/content/notifications' },
						{ match: (u) => u.includes('opr') || u.includes('opera'), url: 'opera://settings/content/notifications' },
						{ match: (u) => u.includes('chrome') && !u.includes('edg') && !u.includes('opr'), url: 'chrome://settings/content/notifications' },
						{ match: (u) => u.includes('firefox'), url: 'about:preferences#privacy' }
					];
					for (const entry of mappings) {
						if (entry.match(ua)) {
							const popup = window.open(entry.url, '_blank');
							return !!popup;
						}
					}
				} catch (err) {
					console.warn('No se pudo abrir la configuraci√≥n de notificaciones:', err);
				}
				return false;
			}

			function getNotificationPermissionLabel() {
				if (!('Notification' in window)) return 'Notificaciones: no soportadas';
				switch (Notification.permission) {
					case 'granted':
						return 'Notificaciones: activadas';
					case 'denied':
						return 'Notificaciones: bloqueadas';
					default:
						return 'Notificaciones: pendientes';
				}
			}

			function updateSoundStatusLabel(extra = '') {
				if (!soundStatus) return;
				let base;
				if (pendingCustomSoundDataUrl) {
					const kb = Math.round((pendingCustomSoundDataUrl.length * 3 / 4) / 1024);
					base = `Cargado (no guardado): ~${kb} KB${extra ? ' - ' + extra : ''}`;
				} else if (customNotificationDataUrl) {
					const kb = Math.round((customNotificationDataUrl.length * 3 / 4) / 1024);
					base = `Actual: personalizado (~${kb} KB)`;
				} else {
					base = 'Actual: predeterminado';
				}
				const permissionInfo = getNotificationPermissionLabel();
				soundStatus.textContent = permissionInfo ? `${base} ¬∑ ${permissionInfo}` : base;
			}

			if (soundFileInput) {
				soundFileInput.addEventListener('change', () => {
					const file = soundFileInput.files && soundFileInput.files[0];
					if (!file) return;
					if (!file.type || !file.type.startsWith('audio/')) {
						alert('Eleg√≠ un archivo de audio v√°lido');
						return;
					}
					// Limitar tama√±o ~ 400 KB para no saturar localStorage
					const MAX_BYTES = 400 * 1024;
					if (file.size > MAX_BYTES) {
						alert('El audio es muy pesado (m√°ximo ~400KB) Eleg√≠ uno m√°s corto');
						return;
					}
					const reader = new FileReader();
					reader.onloadend = () => {
						pendingCustomSoundDataUrl = String(reader.result || '');
						updateSoundStatusLabel(file.name || '');
					};
					reader.readAsDataURL(file);
				});
			}

			if (soundTestBtn) {
				soundTestBtn.addEventListener('click', () => {
					if (pendingCustomSoundDataUrl) {
						const a = new Audio(pendingCustomSoundDataUrl);
						a.play().catch(() => alert('El navegador bloque√≥ la reproducci√≥n. Interactu√° con la p√°gina e intent√° de nuevo'));
						return;
					}
					playNotificationSound();
				});
			}

			if (soundSaveBtn) {
				soundSaveBtn.addEventListener('click', () => {
					if (!pendingCustomSoundDataUrl) {
						alert('Primero eleg√≠ un archivo de audio');
						return;
					}
					setCustomNotificationSound(pendingCustomSoundDataUrl);
					pendingCustomSoundDataUrl = null;
					updateSoundStatusLabel();
					alert('Sonido personalizado guardado');
				});
			}

			if (soundResetBtn) {
				soundResetBtn.addEventListener('click', () => {
					clearCustomNotificationSound();
					pendingCustomSoundDataUrl = null;
					updateSoundStatusLabel();
					alert('Se quit√≥ el sonido personalizado');
				});
			}

			if (soundPermissionBtn) {
				soundPermissionBtn.addEventListener('click', async () => {
					if (!('Notification' in window)) {
						alert('Tu navegador no soporta notificaciones push');
						return;
					}
					const granted = await requestNotificationPermission({ force: true });
					if (granted) {
						updateSoundStatusLabel();
						playNotificationSound();
						alert('las notificaciones est√°n activas');
						return;
					}
					updateSoundStatusLabel();
					if (Notification.permission === 'denied') {
						const opened = attemptOpenNotificationSettings();
						const hint = opened
							? 'Revis√° la pesta√±a o ventana que se abri√≥ y habilit√° las notificaciones para este sitio'
							: 'Abr√≠ la configuraci√≥n de tu navegador y permit√≠ las notificaciones para este sitio manualmente';
						alert('El navegador est√° bloqueando las notificaciones para este sitio. ' + hint);
					} else {
						alert('No se pudo activar el permiso. Verific√° si el navegador bloque√≥ el cuadro de di√°logo e intent√° nuevamente');
					}
				});
			}

			loadCustomNotificationSoundFromStorage();
			try {
				const savedVol = getSavedVolume();
				if (soundVolumeRange) {
					soundVolumeRange.value = Math.round(savedVol * 100);
					if (soundVolumeValue) soundVolumeValue.textContent = `${Math.round(savedVol * 100)}%`;
				}
			} catch {}

			if (soundVolumeRange) {
				soundVolumeRange.addEventListener('input', () => {
					const v = Math.max(0, Math.min(100, Number(soundVolumeRange.value || 100)));
					if (soundVolumeValue) soundVolumeValue.textContent = `${Math.round(v)}%`;
					try { localStorage.setItem('notificationVolume', String(v/100)); } catch {}
				});
			}



			function subscribeFirestoreHistory(userKey) {
				if (unsubscribeHistoryFS) { try { unsubscribeHistoryFS(); } catch {} unsubscribeHistoryFS = null; }
				try {
					const col = collection(fs, 'mensajes');
					const normalized = (userKey || '').toLowerCase();
					const unsubs = [];
					const changeHandler = (snap) => {
						const changes = snap.docChanges();
						for (const ch of changes) {
							const d = ch.doc;
							const data = d.data() || {};
							const id = data.rtdbKey || d.id;
							const tsFromCreatedAt = data.createdAt && typeof data.createdAt.toMillis === 'function' ? data.createdAt.toMillis() : null;
							const ts = (typeof data.x === 'number') ? data.x : (typeof data.ts === 'number' ? data.ts : (tsFromCreatedAt ?? (d.createTime ? d.createTime.toMillis() : Date.now())));
							// Determinar tipo e hidratar claves cortas
							let inferredType = data.type;
							if (!inferredType) {
								if (data.y === 'i' || data.i) inferredType = 'image';
								else if (data.y === 'a' || data.a) inferredType = 'audio';
								else if (data.y === 'p' || data.p) inferredType = 'pdf';
								else if (data.t || data.text) inferredType = 'text';
							}
							const msg = {
								type: inferredType || undefined,
								t: data.t || data.text || null,
								i: data.i || data.imageDataUrl || data.imageUrl || null,
								a: data.a || data.audioDataUrl || null,
								p: data.p || data.pdfDataUrl || data.pdfUrl || null,
								n: data.n || data.name || null,
								s: data.s || data.sender || 'An√≥nimo',
								r: data.r || data.role || 'user',
								x: ts,
								y: data.y || undefined,
								isSticker: !!data.isSticker,
								reactionHeart: !!data.reactionHeart
							};
							if (ch.type === 'added') {
								appendMessageOnce(id, msg, userKey);
							} else if (ch.type === 'modified') {
								handleChildChanged(id, msg, userKey);
							} else if (ch.type === 'removed') {
								// opcional: eliminar del DOM si fuera necesario
							}
						}
					};
					unsubs.push(onSnapshot(fsQuery(col, where('userKeyNormalized', '==', normalized)), changeHandler, (err) => console.warn('Error hist FS normalized', err)));
					if (normalized !== userKey) {
						unsubs.push(onSnapshot(fsQuery(col, where('userKey', '==', userKey)), changeHandler, (err) => console.warn('Error hist FS legacy', err)));
					}
					unsubscribeHistoryFS = () => { unsubs.forEach(u => { try { u(); } catch {} }); };
				} catch (err) {
					console.warn('No se pudo suscribir a historial FS', err);
				}
			}

			// --- Lista de usuarios para el admin ---
			const userListEl = document.getElementById('userList');
			function clearUserList() { userListEl.innerHTML = ''; }

				function teardownAdminSubscriptions() {
					if (unsubscribeAliases) {
						unsubscribeAliases();
						unsubscribeAliases = null;
					}
					if (unsubscribeConversationsMeta) {
						unsubscribeConversationsMeta();
						unsubscribeConversationsMeta = null;
					}
					if (unsubscribeAdminReads) {
						try { unsubscribeAdminReads(); } catch {}
						unsubscribeAdminReads = null;
					}
					if (unsubscribeAdminNotes) {
						try { unsubscribeAdminNotes(); } catch {}
						unsubscribeAdminNotes = null;
					}
					conversations = {};
					userAliases = {};
					conversationMeta = {};
					adminNotes = {};
					knownUserKeys = new Set();
					userListHydrated = false;
					closeContextMenu();
				}

				function renderUserList() {
					clearUserList();
					const q = (document.getElementById('userSearch')?.value || '').trim().toLowerCase();
					if (q) {
						console.log('Buscando usuarios con t√©rmino:', q);
					}
					const combinedKeys = new Set(Object.keys(conversationMeta || {}));
					Object.keys(userAliases || {}).forEach(key => combinedKeys.add(key));
					const newKeys = [];
					combinedKeys.forEach(userKey => {
						if (!knownUserKeys.has(userKey)) {
							knownUserKeys.add(userKey);
							if (userListHydrated) {
								newKeys.push(userKey);
							}
						}
					});
					Array.from(knownUserKeys).forEach(userKey => {
						if (!combinedKeys.has(userKey)) {
							knownUserKeys.delete(userKey);
						}
					});
					newKeys.forEach(userKey => {
						notifyNewConversation(userKey);
					});
					const users = Array.from(combinedKeys).filter(u => {
						if (!q) return true; // Sin b√∫squeda, mostrar todos
						const displayName = (getDisplayName(u) || '').toLowerCase();
						const userKey = (u || '').toLowerCase();
						// Buscar tanto en el alias como en el username
						return displayName.includes(q) || userKey.includes(q);
					});
					const sortedUsers = users.sort((a, b) => {
						const metaA = conversationMeta[a];
						const metaB = conversationMeta[b];
						const tsA = metaA && typeof metaA.lmts === 'number' ? metaA.lmts : (metaA && metaA.ua) || 0;
						const tsB = metaB && typeof metaB.lmts === 'number' ? metaB.lmts : (metaB && metaB.ua) || 0;
						if (tsA !== tsB) {
							return tsB - tsA;
						}
						const nameA = getDisplayName(a) || '';
						const nameB = getDisplayName(b) || '';
						return nameA.localeCompare(nameB, 'es', { sensitivity: 'base' });
					});
					sortedUsers.forEach(userKey => {
						const btn = document.createElement('button');
						btn.className = 'btn';
						btn.style.justifyContent = 'flex-start';
						btn.style.width = '100%';
						btn.dataset.userKey = userKey;
						const img = document.createElement('img');
						img.src = 'assets/logo.png';
						img.alt = 'logo';
						img.className = 'list-avatar';
						const span = document.createElement('span');
						span.textContent = getDisplayName(userKey) || userKey;
						btn.appendChild(img);
						span.style.flex = '1';
						btn.appendChild(span);
						const meta = conversationMeta[userKey] || {};
						if (meta.lastMessagePreview) {
							const preview = document.createElement('div');
							preview.textContent = meta.lastMessagePreview;
							preview.style.cssText = 'font-size:11px;color:#a0a6b7;margin-top:2px;text-align:left;';
							btn.appendChild(preview);
						}
						let unreadCount = (typeof unreadCounts[userKey] === 'number') ? unreadCounts[userKey] : 0;
						if (unreadCount === 0) {
							const readTs = adminReadState[userKey] || 0;
							const lastTs = (meta && typeof meta.lastMessageTs === 'number') ? meta.lastMessageTs : 0;
							unreadCount = (lastTs > readTs && userKey !== selectedUserKey) ? 1 : 0;
						}
						if (unreadCount > 0) {
							const badge = document.createElement('span');
							badge.className = 'unread-badge';
							badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
							badge.style.cssText = 'background:#ff6b6b;color:#fff;border-radius:999px;padding:2px 8px;font-size:11px;font-weight:600;margin-left:auto;';
							btn.appendChild(badge);
						}
						if (selectedUserKey === userKey) {
							btn.style.borderColor = '#2a5fff40';
						}
						btn.oncontextmenu = (e) => {
							e.preventDefault();
							e.stopPropagation();
							showContextMenu(userKey, e.clientX, e.clientY);
						};
						btn.onclick = () => {
							if (selectedUserKey !== userKey) {
								loadChat(userKey);
							}
						};
						userListEl.appendChild(btn);
					});
					if (!selectedUserKey || !combinedKeys.has(selectedUserKey)) {
						selectedUserKey = sortedUsers.length ? sortedUsers[0] : null;
						if (selectedUserKey) {
							loadChat(selectedUserKey);
						} else {
							clearChat();
						}
					} else {
						updateActiveChatHeader();
					}
					if (!userListHydrated) {
						userListHydrated = true;
					}
				}

				function ensureAdminSubscriptions() {
					if (!unsubscribeAliases) {
						// Cargar aliases desde Firestore en lugar de RTDB
						const aliasesCol = collection(fs, 'userAliases');
						unsubscribeAliases = onSnapshot(aliasesCol, (snap) => {
							const newAliases = {};
							snap.forEach((docSnap) => {
								const data = docSnap.data();
								if (data && data.alias) {
									newAliases[docSnap.id] = data.alias;
								}
							});
							userAliases = newAliases;
							renderUserList();
						}, (error) => {
							console.warn('Error al cargar aliases desde Firestore:', error);
							userAliases = {};
						});
					}
					if (!unsubscribeConversationsMeta) {
						const convsMetaCol = collection(fs, 'conversaciones');
						unsubscribeConversationsMeta = onSnapshot(convsMetaCol, (snap) => {
							const nextMeta = {};
							snap.forEach((docSnap) => {
								const data = docSnap.data() || {};
								const normalized = {
									...data,
									updatedAtMs: data.updatedAt && typeof data.updatedAt.toMillis === 'function' ? data.updatedAt.toMillis() : null
								};
								nextMeta[docSnap.id] = normalized;
							});
							conversationMeta = nextMeta;
							renderUserList();
						}, (err) => console.warn('Error suscribiendo metadata de conversaciones', err));
					}
					// Suscribirse a estado de lectura del admin
					if (!unsubscribeAdminReads) {
						try {
							const readsDoc = doc(fs, 'adminState', 'reads');
							unsubscribeAdminReads = onSnapshot(readsDoc, (snap) => {
								adminReadState = snap.exists() ? (snap.data() || {}) : {};
								renderUserList();
							}, (err) => console.warn('Error suscribiendo admin reads', err));
						} catch (err) {
							console.warn('No se pudo suscribir a admin reads', err);
						}
					}
					// Suscribirse a notas del admin
					if (!unsubscribeAdminNotes) {
						try {
							const notesCol = collection(fs, 'adminNotes');
							unsubscribeAdminNotes = onSnapshot(notesCol, (snap) => {
								adminNotes = {};
								snap.forEach((docSnap) => {
									const data = docSnap.data();
									if (data && data.note !== undefined) {
										adminNotes[docSnap.id] = data.note;
									}
								});
								updateActiveChatHeader();
							}, (err) => console.warn('Error suscribiendo admin notes', err));
						} catch (err) {
							console.warn('No se pudo suscribir a admin notes', err);
						}
					}
					renderUserList();
				}

				let contextMenuEl = null;
				function closeContextMenu() {
					if (contextMenuEl) {
						contextMenuEl.remove();
						contextMenuEl = null;
					}
				}

				function showContextMenu(user, x, y) {
					closeContextMenu();
					contextMenuEl = document.createElement('div');
					contextMenuEl.style.position = 'fixed';
					contextMenuEl.style.left = x + 'px';
					contextMenuEl.style.top = y + 'px';
					contextMenuEl.style.background = '#181818';
					contextMenuEl.style.border = '1px solid #333';
					contextMenuEl.style.borderRadius = '8px';
					contextMenuEl.style.boxShadow = '0 4px 16px #0008';
					contextMenuEl.style.zIndex = 9999;
					contextMenuEl.style.minWidth = '140px';
					contextMenuEl.innerHTML = `
						<button style="all:unset;display:block;width:100%;padding:10px 16px;cursor:pointer;color:#fff;font-size:15px;" id="renameBtn">Cambiar nombre</button>
						<button style="all:unset;display:block;width:100%;padding:10px 16px;cursor:pointer;color:#ff6b6b;font-size:15px;" id="deleteChatBtn">Borrar</button>
					`;
					document.body.appendChild(contextMenuEl);
					contextMenuEl.querySelector('#renameBtn').onclick = () => {
						closeContextMenu();
						const actual = getDisplayName(user);
						const nuevo = prompt('Nuevo nombre para el usuario (solo visible para administrador):', actual || user);
						if (nuevo !== null) {
							renameUserChat(user, nuevo);
						}
					};
					contextMenuEl.querySelector('#deleteChatBtn').onclick = () => {
						closeContextMenu();
						if (confirm('¬øSeguro que quieres borrar este chat? Esta acci√≥n no se puede deshacer.')) {
							deleteChatFromList(user);
						}
					};
				// Funci√≥n para borrar completamente el chat (UI + RTDB + Firestore)
				async function deleteChatFromList(userKey) {
					const normalized = (userKey && userKey.toLowerCase) ? userKey.toLowerCase() : (userKey || '');
					try {
						// 1) Eliminar UI local y memoria
						if (userListPanel) {
							const btn = userListPanel.querySelector(`[data-user-key="${userKey}"]`);
							if (btn) btn.remove();
						}
						if (conversations && conversations[userKey]) delete conversations[userKey];
						if (conversationMeta && conversationMeta[userKey]) delete conversationMeta[userKey];
						if (knownUserKeys && knownUserKeys.has(userKey)) knownUserKeys.delete(userKey);
						if (selectedUserKey === userKey) {
							selectedUserKey = null;
							clearChat();
							updateActiveChatHeader();
						}

						// 2) Borrar RTDB: conversaci√≥n y alias (legacy)
						try { await remove(ref(db, 'chat/conversaciones/' + userKey)); } catch (err) { console.warn('No se pudo borrar RTDB conversaci√≥n:', err); }
						try { await remove(ref(db, 'chat/aliases/' + normalized)); } catch (err) { /* opcional - legacy */ }

						// 3) Firestore: borrar metadata de conversaci√≥n, nota del admin y alias
						try { await deleteDoc(doc(fs, 'conversaciones', userKey)); } catch (err) { console.warn('No se pudo borrar metadata de conversaci√≥n:', err); }
						try { await deleteDoc(doc(fs, 'adminNotes', userKey)); } catch (err) { /* opcional */ }
						try { await deleteDoc(doc(fs, 'userAliases', normalized)); } catch (err) { /* opcional - alias */ }

						// 4) Firestore: borrar todos los mensajes de ese usuario
						try {
							const colRef = collection(fs, 'mensajes');
							// Preferir userKeyNormalized, y fallback por userKey
							const snaps = [];
							snaps.push(await getDocs(fsQuery(colRef, where('userKeyNormalized', '==', normalized))));
							if (normalized !== userKey) {
								snaps.push(await getDocs(fsQuery(colRef, where('userKey', '==', userKey))));
							}
							const batch = writeBatch(fs);
							let batched = 0;
							for (const snap of snaps) {
								snap.forEach(d => { batch.delete(d.ref); batched++; });
							}
							if (batched > 0) await batch.commit();
						} catch (err) { console.warn('No se pudieron borrar mensajes en Firestore:', err); }

						// 5) Opcional: limpiar estado de lectura del admin (deja null si existe campo)
						try {
							await setDoc(doc(fs, 'adminState', 'reads'), { [userKey]: null }, { merge: true });
						} catch (err) { /* opcional */ }

					} catch (err) {
						alert('No se pudo borrar el chat: ' + err);
					}
				}

				}
				document.addEventListener('click', closeContextMenu);
					document.addEventListener('contextmenu', (e) => {
						if (contextMenuEl && (contextMenuEl === e.target || contextMenuEl.contains(e.target))) return;
						if (contextMenuEl) closeContextMenu();
				});

					async function renameUserChat(userKey, aliasValue) {
						try {
							const alias = (aliasValue || '').trim();
							const currentAlias = userAliases[userKey] || '';
							
							if (!alias && !currentAlias) {
								return;
							}
							if (alias === currentAlias) {
								return;
							}
							
							const normalizedKey = (userKey || '').toLowerCase();
							const aliasDocRef = doc(fs, 'userAliases', normalizedKey);
							
							if (!alias) {
								// Eliminar alias si est√° vac√≠o
								await deleteDoc(aliasDocRef);
								console.log('Alias eliminado para:', userKey);
							} else {
								// Guardar o actualizar alias en Firestore
								await setDoc(aliasDocRef, {
									alias: alias,
									userKey: normalizedKey,
									updatedAt: fsServerTimestamp()
								}, { merge: true });
								console.log('Alias guardado para:', userKey, '‚Üí', alias);
							}
							
							// Actualizar localmente
							if (!alias) {
								delete userAliases[userKey];
								delete userAliases[normalizedKey];
							} else {
								userAliases[userKey] = alias;
								userAliases[normalizedKey] = alias;
							}
							
							// Actualizar UI
							if (selectedUserKey === userKey) {
								updateActiveChatHeader();
							}
							renderUserList();
						} catch (error) {
							console.error('Error al cambiar nombre de usuario:', error);
							alert('No se pudo cambiar el nombre. Intenta de nuevo.');
						}
					}

			loginBtn.addEventListener('click', async () => {
				const user = (usernameEl.value || '').trim();
				const pass = (passwordEl.value || '').trim();
				if (user === USER1 && pass === USER2) {
					currentUser = { name: 'Administrador', role: 'admin' };
					selectedUserKey = null;
					loginError.textContent = '';
					setView(true);
					return;
				}
				if (!user) {
					loginError.textContent = 'Ingres√° un usuario para continuar';
					usernameEl.focus();
					return;
				}
				if (!pass) {
					loginError.textContent = 'Ingres√° una contrase√±a para continuar';
					passwordEl.focus();
					return;
				}
				const normalized = user.toLowerCase();
				currentUser = { name: normalized, role: 'user', displayName: user };
				selectedUserKey = normalized;
				try {
					const aliasRef = ref(db, 'chat/aliases/' + normalized);
					const snap = await get(aliasRef);
					if (!snap.exists()) {
						await set(aliasRef, user);
					}
				} catch (err) {}
				loginError.textContent = '';
				setView(true);
				try {
					if (pendingSharedPdfFile) {
						const f = pendingSharedPdfFile;
						pendingSharedPdfFile = null;
						sendPdfAttachment(f).catch(() => {});
					}
				} catch {}
			});

			logoutBtn.addEventListener('click', () => {
				currentUser = { name: null, role: 'user' };
				selectedUserKey = null;
				setView(false);
			});

		document.addEventListener('keydown', (e) => {
			if (e.key === 'Escape') {
				const dlg = document.getElementById('imgDialog');
				if (dlg && dlg.open) return; 
				if (chatCard.style.display !== 'none') {
					logoutBtn.click();
				}
			}
		});
		
		// Configurar el buscador de usuarios
		const userSearchInput = document.getElementById('userSearch');
		if (userSearchInput) {
			userSearchInput.addEventListener('input', () => {
				if (currentUser.role === 'admin') {
					renderUserList();
				}
			});
			console.log('Buscador de usuarios configurado correctamente');
		}
		
		// Configurar toggle del panel de accesos r√°pidos
		const shortcutsToggleBtn = document.getElementById('shortcutsToggleBtn');
		
		if (shortcutsToggleBtn && shortcutsCard) {
			// Cargar estado guardado
			let isCollapsed = false;
			try {
				const saved = localStorage.getItem('shortcutsPanelCollapsed');
				if (saved === 'true') {
					isCollapsed = true;
					shortcutsCard.classList.add('collapsed');
					chatRow.classList.add('shortcuts-collapsed');
					shortcutsToggleBtn.textContent = '‚ñ∂';
					shortcutsToggleBtn.title = 'Mostrar panel de accesos r√°pidos';
				} else {
					shortcutsToggleBtn.textContent = '‚óÄ';
					shortcutsToggleBtn.title = 'Ocultar panel de accesos r√°pidos';
				}
			} catch (e) {}
			
			shortcutsToggleBtn.addEventListener('click', () => {
				isCollapsed = !isCollapsed;
				
				if (isCollapsed) {
					shortcutsCard.classList.add('collapsed');
					chatRow.classList.add('shortcuts-collapsed');
					shortcutsToggleBtn.textContent = '‚ñ∂';
					shortcutsToggleBtn.title = 'Mostrar panel de accesos r√°pidos';
				} else {
					shortcutsCard.classList.remove('collapsed');
					chatRow.classList.remove('shortcuts-collapsed');
					shortcutsToggleBtn.textContent = '‚óÄ';
					shortcutsToggleBtn.title = 'Ocultar panel de accesos r√°pidos';
				}
				
				// Guardar estado
				try {
					localStorage.setItem('shortcutsPanelCollapsed', isCollapsed.toString());
				} catch (e) {}
			});
			
			console.log('Toggle de panel de accesos r√°pidos configurado');
		}
		
		// Funci√≥n de emergencia para resetear el panel (disponible en consola)
		window.resetShortcutsPanel = function() {
			try {
				localStorage.removeItem('shortcutsPanelCollapsed');
				const card = document.getElementById('shortcutsCard');
				const row = document.getElementById('chatRow');
				const btn = document.getElementById('shortcutsToggleBtn');
				
				if (card) {
					card.classList.remove('collapsed');
					card.style.display = 'flex';
				}
				if (row) {
					row.classList.remove('shortcuts-collapsed');
				}
				if (btn) {
					btn.textContent = '‚óÄ';
					btn.title = 'Ocultar panel de accesos r√°pidos';
					btn.style.display = 'flex';
				}
				
				console.log('Panel de accesos r√°pidos reseteado exitosamente');
				alert('Panel de accesos r√°pidos reseteado. Recarga la p√°gina si es necesario.');
			} catch (e) {
				console.error('Error al resetear panel:', e);
			}
		};
		
		updateClosedStateUI();
		setInterval(updateClosedStateUI, 60 * 1000);
		setView(false);
		ensureAgeGate();
		if (closedDismissBtn) {
			closedDismissBtn.addEventListener('click', () => {
				try { sessionStorage.setItem('closedOverlayDismissed', '1'); } catch {}
				if (closedFullOverlay) closedFullOverlay.style.display = 'none';
			});
		}
	</script>
</body>
</html>